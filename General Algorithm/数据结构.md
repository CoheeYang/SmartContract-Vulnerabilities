



## Segment Tree

权值线段shu

#### 左对齐

一个节点（或一个区间块）**左对齐**，就是它的起点 `left` 是该节点覆盖长度 `size` 的整数倍──也就是说 `left % size == 0`。等价的二进制判断是低 `log2(size)` 位全为 0，例如 `left & (size-1) == 0`。

举例（假设 `size = 4`）：

- 合格的左对齐起点：`0, 4, 8, 12, ...`（二进制末两位是 `00`）
- 不合格的：`1, 2, 3, 5, ...`（这些起点不是 4 的倍数）

Segment Tree（或二叉分割树）天然是按 **长度为 2 的幂** 的块组织的：根覆盖 `[0, rootWidth)`（`rootWidth` 常设为 2 的幂），每往下一层，块长度减半；而每个块的起点必然是该块长度的倍数（这就是“对齐”）。

比如[0,1,2,3,4,5,6,7]向下分第一层[0,3]，[4,7]。其`width=4`，两个`left`均满足`_left % width == 0`

```bash
		[0,1,2,3,4,5,6,7]宽8
			/      \
		[0,3]	  [4,7]  宽4的
		/	\	   /  \
	  [0,1][2,3] [4,5] [6,7] 宽2的
	  / \   / \   / \   / \ 
    [0][1] [2][3][4][5][6][7] 宽1的
```

而且还有个很好的性质就是如果完美知道标签`index`，就知道该最先出现的以此`index`为左边的最大宽度是多少，该值就是`lsb(index)`。其中

```solidity
function lsb(uint24 x) pure returns (uint24) {
    unchecked {
        return x & (~x + 1);
    }
    //x取反+1后 位与x得到最小位
}
```

比如`index=6`,二进制为`0110`,`lsb=2(0010)`，意味着其最宽就是在宽2上，是最先出现的地方。



把节点要求为“左对齐”可以带来很多好处：

1. **直接对应树上的节点**
   - 如果一个区间是左对齐并且长度是 `2^k`，它恰好就是树中某个完整节点的覆盖区间（不用拆分）。
   - 这样就可以直接使用该节点存储的聚合值（sum/min/max）或 lazy 标记，而不用访问其子节点。
2. **能用位运算快速判断/计算**
   - 判断对齐：`(left & (size-1)) == 0`，非常便捷、常数时间。
   - `lsb(left)` 给出从 `left` 出发能对齐的**最大** `2^k`（即最大的 `size`），这是快速找到能“吃掉”区间左端的最大整块的方法。
3. **方便贪心分解区间（少节点覆盖）**
   - 任意区间 `[L,R)` 可以按“左端驱动”的贪心策略分解为少量的左对齐幂二块。数量上界是 `≤ 2·log(rootWidth)`，所以查询/更新的复杂度是对数级的。
   - 示例：`[3,13)` → `[3,4), [4,8), [8,12), [12,13)`（这些块都是按左对齐幂二块得到的）。
4. **结构与索引一一对应，便于编码与压缩键（Key）设计**
   - 把 `(left, size)` 打包成一个 Key，就能标识树上唯一一个节点（因为对齐保证了同一 `left` 不会同时对应多个不同层的完整块）。这方便存储、查找、合并操作（正是你代码里 `KeyImpl.make(_left, width)` 的用意）。
5. **利于 lazy propagation / 批量更新**
   - 如果你能把某个更新或查询直接映射到某个对齐节点，就可以直接应用或读取节点上的 lazy 标志或预计算值，而不必去一片片更新叶子，效率高且实现简单。