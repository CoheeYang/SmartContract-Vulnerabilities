

[TOC]



Bug复盘：

Owen- try cathc issue

ABI-ecode stri https://solodit.cyfrin.io/issues/m-04-cidnft-broken-tokenuri-function-code4rena-canto-identity-protocol-canto-identity-protocol-contest-git

涉及外部dex，但是却没有限制传输的bytes data导致的 bypasslimit https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85

1/64 rule导致的问题 https://solodit.cyfrin.io/issues/h-08-gas-limit-check-is-inaccurate-leading-to-an-operator-being-able-to-fail-a-job-intentionally-code4rena-holograph-holograph-contest-git



1. ERC20 transfer/transferFrom不总是revert，有时候会返回0/false



## Bug list

表格：Rarity>=B时，有Heuristics

A：极少人找到的bug，此类bug会让你获得非常可观收入。

B：较少的人找到的bug，此类bug需要一定水平，并带给你一定的收入。

C：一般性的bug，比如一些写错或明显的DoS，reentrancy等经典bug。

| No.  | Description                                                  | Link                                                         | Classification                    | Protocal Class                                | Rarity | Heuristics                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------- | --------------------------------------------- | ------ | ------------------------------------------------------------ |
| 1    | 持有51%投票权后通过再铸造超级投票权，以通过那些需要几乎100%投票权才能完成的proposal | [Party-Protocal](https://solodit.cyfrin.io/issues/h-01-the-51-majority-can-hijack-the-partys-precious-tokens-through-an-arbitrary-call-proposal-if-the-addpartycardsauthority-contract-is-added-as-an-authority-in-the-party-code4rena-party-protocol-party-protocol-git) | 51% attack                        | Governance                                    | B      |                                                              |
| 2    | ERC20作为NFT持有股权，通过建立任意proposal将其所有的ERC20转给attacker，之后attacker拿这些ERC20换整个NFT | [PartyDAO](https://solodit.cyfrin.io/issues/h-06-a-majority-attack-can-steal-precious-nft-from-the-party-by-crafting-and-chaining-two-proposals-code4rena-partydao-partydao-contest-git) | 51% attack                        | Governance                                    | B      |                                                              |
| 3    | lack zero address check 导致潜在的51% attack                 | [Veto]( https://solodit.cyfrin.io/issues/m-11-loss-of-veto-power-can-lead-to-51-attack-code4rena-nouns-builder-nouns-builder-contest-git) | 51% attack                        | Governance                                    | B      |                                                              |
| 4    |                                                              |                                                              |                                   |                                               |        |                                                              |
| 5    | 写错的，25%写成了4，导致错误                                 | [IQ-AI]((https://code4rena.com/reports/2025-01-iq-ai#medium-risk-findings-1)) | 写错（数值填错）                  |                                               | C      |                                                              |
| 6    | 在流动性管理的合约中，有一个加入流动性的函数会判断对应代币对池子是否存在，如果不存在则创建一个池子，如果存在则使用这个池子。但是这个好玩的是这个池子任何人都能创建，也能定义手续费。 | [IQ-AI](https://code4rena.com/reports/2025-01-iq-ai#medium-risk-findings-2) | AcessControl                      |                                               |        |                                                              |
| 7    | 经典Donation Attack                                          | [IQ-AI]( https://code4rena.com/reports/2025-01-iq-ai#m-02-attacker-can-dos-liquidity-migration-in-liquiditymanagersol) | Donation Attack                   |                                               |        |                                                              |
| 8    | 写错，检验了stateVariable，而非input                         | [IQ-AI](https://code4rena.com/reports/2025-01-iq-ai#m-03-ineffective-proposal-threshold-validation-allows-setting-arbitrary-high-values) | 写错（数值填错）                  |                                               | C      |                                                              |
| 9    | 由于资金划分管理的不清晰导致用户可能在Operator取手续费后导致资金的减少（fuzzing推荐，对应Invariant用户存入后资金不变） | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#h-01-the-calculation-of-totalassets-could-be-wrong-if-operatorfeeamount--0-this-can-cause-potential-loss-for-the-new-depositors) | Logic Error                       | Staking                                       | B      |                                                              |
| 10   | 合约生态中的front running（ERC4626特有的staking导致的front-running） | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#m-01-user-can-earn-rewards-by-frontrunning-the-new-rewards-accumulation-in-ron-staking-without-actually-delegating-his-tokens) | flash-staking attack              | Staking                                       | A      | 有奖励发放前一瞬间的deposit，并且在之后离场，是staking合约可能存在的常见问题 |
| 11   | Modifier中的require逻辑写错                                  | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#m-02-operators-are-unable-to-perform-any-actions-due-to-incorrect-modifier-implementation) |                                   | Staking                                       | C      |                                                              |
| 12   | 合约中用户将`tgt`转入可以换`titn` ,可是存的那个函数没有先检查是否超过可存的额度，导致用户可能存了`tgt`，但是因为titn有限，之后的用户在取`titn`的时候取不出来 | [Thorwallet](https://code4rena.com/reports/2025-02-thorwallet#finding-description-and-impact) | Limited Precheck（前置check缺失） | Bridge                                        | C      |                                                              |
| 13   | Bridge中独有的bug，当token本身存在（部分）限制转账时（A转B在设计限制了A转账路径），attacker可以通过跨链从X转到另外一个链Y，再通过Y转X中的B账户实现绕开限制（[如LayerZero::OFT中的send方法](https://github.com/LayerZero-Labs/LayerZero-v2/blob/main/packages/layerzero-v2/evm/oapp/contracts/oft/OFTCore.sol)） | [Thorwallet](https://code4rena.com/reports/2025-02-thorwallet#h-2-the-user-can-send-tokens-to-any-address-by-using-two-bridge-transfers-even-when-transfers-are-restricted) | 跨链转账                          | Bridge                                        | A      |                                                              |
| 14   | 通过改变其他用户的flag，导致用户无法成功进行转账             | [ThorWallet](https://code4rena.com/reports/2025-02-thorwallet#m-1-improper-transfer-restrictions-on-non-bridged-tokens-due-to-boolean-bridged-token-tracking-allowing-a-dos-attack-vector) | DoS (改变其他人的数据导致)        | Bridge                                        | C      |                                                              |
| 15   | 锁定流动性池`lock_pool`需要一个创建一个`lock_escrow account`，但是没用check这个account是否已经存在，如果已经存在则会出现DoS | [Pump-science](https://code4rena.com/reports/2025-01-pump-science#h-01-the-lock_pool-operation-can-be-dos) | DoS(提前占据他人数据)             | Bonding Curve                                 |        |                                                              |
| 16   | 函数未成功更新结构体数据                                     | [Pump-science](https://code4rena.com/reports/2025-01-pump-science#h-02-missing-update-of-migration_token_allocation-on-global-struct) |                                   |                                               |        |                                                              |
| 17   | 。。。Pump Science（由于是rust的，这里先空着，之后学rust再补齐） |                                                              |                                   |                                               |        |                                                              |
| 18   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 19   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 20   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 21   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 22   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 23   | 在Flow control中，deposit的flow没有被成功finalize，导致DoS（对于多数flow control都有参考意义） | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-02-deposits-on-long-one-leverage-vault-dont-actually-finalize-the-flow-leading-to-a-denial-of-service-dos) | DoS(缺乏完整逻辑)                 | Strategy                                      | B      |                                                              |
| 24   | PNL损益的计算错误（藏的非常深）                              | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-02-deposits-on-long-one-leverage-vault-dont-actually-finalize-the-flow-leading-to-a-denial-of-service-dos) | Logic error                       | Strategy                                      | B      |                                                              |
| 25   | Mint所计算的shares出现问题，会导致同样的deposit，后续deposit的人反而会有更多shares。根本原因在于在计算“仓位净值”（`netValue`）时，错误地将**positionFee**（挂单手续费）也一并从净值中扣除，导致后续根据`netValue`与已有份额计算新用户应得份额时低估了整个池子的总资产值（`totalAmountBefore`），反过来使得后续每次存入者获得的份额越来越多，从而让“晚入场”的用户占到不公平的份额增益。           （推荐寻找方法：从结果出发，看是否会出现不公平的问题） | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-05-subtracting-position-fee-in-position-net-value-will-lead-to-incorrect-share-allocation) | Logic error                       | Strategy                                      | A      |                                                              |
| 26   | 根据官方文档中，存在多个`orderHandler` 的角色，但是它只写了一个地址。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-02-perpetualvault-can-be-completely-bricked) | Logic error                       | Strategy                                      | C      |                                                              |
| 27   | 为检查创建订单等行为时用户账户所花费的gas是否大于账户余额，`getExecutionGasLimit`会估算总gas量，但是其中计算出现了缺乏估计`swapPath`长度，导致多跳swap（如Link->USDC->Weth）的gas估计失真。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-03-getexecutiongaslimit-reports-a-lower-gas-limit-due-to-gasperswap-miscalculation) | Logic error                       | Strategy                                      | C      |                                                              |
| 28   | `_validatePrice`中存在检查L2 Sequencer是否正常运行的逻辑，Sequencer是L2链中常见的交易排序和打包到L1的关键组件，Chainlink PriceFeed可以监测其是否正常运行。但是项目部署的一个链Avalaunch并非L2，而是L1，且`sequencerUptimeFeed`中的对应地址是硬编码的，导致潜在的DoS。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-04-functions-that-rely-on-chainlink-prices-cannot-be-queried-on-avalanche-due-to-sequencer-uptime-check) | PriceFeed                         | Strategy                                      | B      | 不同链相关的问题，特别是L2 sequencer这一概念的理解           |
| 29   | 对于被清算的仓位，合约中没有对shares进行清算的逻辑，导致后续开仓的人shares不正确 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-05-incorrect-share-accounting-after-liquidation-leading-to-ownership-dilution) | Logic error                       | Strategy                                      | B      |                                                              |
| 30   | `GmxProxy.sol`中的GMX's ADL 行为将Gmx的钱转入`PerpetualVault`，但是`PerpetualVault`的withdraw行为依赖`balanceOf(this)`，如果在withdraw前触发ADL，用户可以获得更多。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-06-user-may-withdraw-more-than-expected-if-adl-event-happens) | Logic error                       | Strategy                                      | B      | 当看见`balanceOf(this)`时检查外部操作此数据的方法            |
| 31   | GMX中的ADL和liquidation行为最后的output token可以是ETH，而非WETH，`GmxProxy.sol`也存在receive函数，如果output是ETH，那么最后会转入`GmxProxy.sol`，但是`GmxProxy.sol`缺乏对应的转出ETH的函数，导致ETH被卡在合约中出不去。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-07-adl-can-result-in-unwrapped-eth-as-output-which-is-not-handled) | Logic error                       | Strategy                                      | A      | 1. 外部依赖交易所的具体情况值得注意 <br />         2. 类似的output token是ETH,而非ERC20 token的情况值得考虑 |
| 32   | 这也是一个GMX原生设计上的点，GMX对于`MarketProps`中的`indexToken `指数代币，并非全是ERC20标准的合约，比如对BTC/USD，它设计的indexToken的合约地址是一个chainlink Aggregator 合约地址，此时任何关于`indexToken`的如balanceOf的调用都是错误的 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-08-fetching-indextokenbalanceof-will-always-revert-for-btc-market) | Logic error                       | Strategy                                      | A      | 关注外部交易所对于BTC,ETH等代币的合约是否采用ERC20标准       |
| 33   | `totalDepositAmount`在liquidation和withdraw行为中都没有更新，导致`totalDepositAmount`在deposit中一直上涨触发`maxCapReached` | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-09-new-deposits-be-incorrectly-rejected-due-to-false-maxcapreached-errors) | Logic error                       | Strategy                                      | A      | 跟踪并检查state variable是否正确的更新，是否有办法扭曲它     |
| 34   | 错误的指数exp处理，在exp为偶数除以2后又加上了1               | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-01-early-72-digit-adjustment-in-sqrt-will-lead-to-incorrect-result-exponent-calculation) | Logic error                       | MathLib                                       | B      |                                                              |
| 35   | 0的sqr会revert，这很错误                                     | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-02-sqrt-function-silently-reverts-the-entire-control-flow-when-a-packed-float-of-0-value-is-passed) | Logic error                       | MathLib                                       | C      |                                                              |
| 36   | Ln接受0值和负值输入                                          | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-03-natural-logarithm-function-silently-accepts-invalid-non-positive-inputs) | Logic error                       | MathLib                                       | C      |                                                              |
| 37   | `function eq(packedFloat a, packedFloat b) internal pure returns (bool retVal) {         retVal = packedFloat.unwrap(a) == packedFloat.unwrap(b);     }`<br />出现错误，它将一个自己设计的type `packedFloat`unwarp回`uint256`来进行比较，但是这种比较会出现同一个数字，72位表达和38位表达最后比较的结果会不相等。 | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-04-unwrapping-while-equating-inside-the-eq-function-fails-to-account-for-the-set-l_matissa_flag) | Logic error                       | MathLib                                       | B      | 同一数据，由于表达格式flag不同导致`eq`失效                   |
| 38   | 最基本的转化函数`toPackedFloat`在M和L中间的判断的数中，有一个明显的截断除法，导致数据很多的数直接转为M尾数，造成精度的丢失 | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-05-precision-loss-in-topackedfloat-function-when-mantissa-is-in-range-max_m_digit_number-min_l_digit_number) | Logic error                       | MathLib                                       | B      | 格式转化中的截断div，是否会导致过量的数据丢丢失              |
| 39   | auto scaling rule的方法在`toPackedFloat`和其他地方都不一致   | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#m-01-inconsistent-mantissa-size-auto-scaling-between-packedfloat-encoding-and-calculations-will-lead-to-unacceptable-rounding-errors) | Logic error                       | MathLib                                       | A      | 非常有争议，但是确实也提供了一个好的角度；是否全局上存在不一致的rule |
| 40   | 这个案例非常好的阐释了什么叫没有用的保护。函数在交易的内部进行计算的slippage protection是多少，而且还依赖于`uni.getAmountOut`，攻击者可以和往常一样进行三明治攻击，此时函数内得到的minAmount已经被操控，这个protection一点用都没有。 | [Pashov Audit Group](https://solodit.cyfrin.io/issues/h-01-_swap-is-vulnerable-to-sandwich-attacks-pashov-audit-group-none-gacha_2025-01-27-markdown) | Sandwich Attack                   |                                               | A      | 任何涉及swap的buy/sell都需要有主入口函数的slippage protection，`minAmount`，内部计算动态计算是没用的。 |
| 41   | 和之前gamma依赖交易所claim的ETH无法转出的bug类似，此bug由于ERC4626的escrow只定义了一种asset token，如果从外部的`Morpho`借贷平台获取其他token时会卡住出不来。 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/527) | Logic error                       | StableSwap （无滑点的eBTC与btc计价资产的swap) | A      | 非常有意思，和之前gamma的ETH无法转出类似，这里是其他token无法转出。所以检查外部平台所发给合约的奖励也是非常重要的 |
| 42   | eBTC作为和其他BTC资产交互的平台，在`EbtcBSM::sellAsset()`中，并没有考虑到decimal的不一致的情况，像 [cbBTC](https://etherscan.io/address/0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf#readProxyContract#F11), [LBTC](https://etherscan.io/address/0x8236a87084f8b84306f72007f36f2618a5634494#readProxyContract#F7) and [ether.fi BTC](https://etherscan.io/address/0x657e8c867d8b37dcc18fa4caead9c45eb088c642#readContract#F5) 都是8位，而eBTC是18位 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/505) | ERC20                             | StableSwap                                    | B      | 交换外部erc20的decimal是否存在对齐的问题。有没有`*token.decimal()` |
| 43   | chainlink合约中本应该返回`tBTC/BTC`的answer数值，但是最后计算中`_convertAnswer()`中写的计算方法是`BTC/tBTC` | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/275) | PriceFeed                         | StableSwap                                    | C      | priceFeed data的处理写反了，这是很low的bug，但是也是可能在priceFeed中出现的。 |
| 44   | 合约试图获得`BTC/USD` and `tBTC/USD`的价格，并转转化为`BTC/tBTC`的价格，但是两个价格的heartbeat差距太大，一个`86400s`，一个`3600s`，这导致最后乘法永远拿老数据和新数据乘。<br />同时它也将两个`updatedAt`选最小来进行比较，这也导致check staleness会出现问题。 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/259) | PriceFeed                         | StableSwap                                    | B      | 涉及priceFeed中的类似的staleness check和转化问题，切记priceFeed的heartbeat差距的问题。 |
| 45   | 在migration到另外一个escrow的操作中，由于对外部redeem操作可能revert导致invariant的失败，即migration fail。这些失败的情况包括：<br />1.外部vault pause或者frozen <br />2.没有shares  to redeem<br />3.redeem的share超过maxRedeem的限制 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/131) | Logic error                       | StableSwap                                    | B      | 1. Invariant的打破<br/>2. 仔细检查external call revert的情况 |
| 46   | 新的Fork中引入了8位的BTC相关的抵押物，原Liquidity v2的抵押物都是18位的 | [BitVault](https://code4rena.com/reports/2025-04-bitvault#m-01-the-current-implementation-is-incompatible-with-wbtc-as-collateral-token) | ERC20                             | Lending                                       | B      | 其实这个bug并不难找，只是项目根本没人做，因为项目只有15000预算，且代码3000+<br />可是又由于是fork代码，这个价格也合理 |
| 47   | 可以被bypass的whitelist逻辑，NFT的mint对象必须是whitelist的，但是NFT是可交易的，这种whitelist一点用都没用 | [BitVault](https://code4rena.com/reports/2025-04-bitvault#m-02-non-whitelisted-owner-can-also-holdown-a-trovenft) | Access Control                    | Lending                                       | A      | bypass whitelist                                             |
| 48   | 一个关于ERC4626的问题，ERC4626`deposit/withdraw`最后return shares，而非amount，而开发者一直一位是amount来进行deploy等操作的计算 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-01-users-may-encounter-losses-on-assets-deposited-through-strategysupplyerc4626) | Logic error                       | Strategy                                      | B      | ERC4626的deposit/withdraw输出的是shares<br />(刨根问底，一个external call即使最后是接口也要弄清最后的逻辑) |
| 49   | `harvest()`作为一个修改state variable的函数，会更新账户总资产并return`balanceChange`，但他是public函数，且收手续费的`_harvestAndMintFees`也会需要它来判断`balanceChange>0 ? 收手续费:不收`，这就导致任何人都能调用`harvest`更新数据逃避手续费。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-02-anyone-can-call-strategysupplybaseharvest-allowing-users-to-avoid-paying-performance-fees-on-interest) | Access Control                    | Strategy                                      | B      | public函数很可怕，能更新state variable的public函数更可怕     |
| 50   | `StrategySupplyBase.undeploy`没有更新state variable`_deployedAmount`，逻辑缺失 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-03-_deployedamount-not-updated-on-strategysupplybaseundeploy-preventing-performance-fees-from-being-collected) | Logic error                       | Strategy                                      | C      |                                                              |
| 51   | 合约中使用的ERC4626用的18位decimal，但是这个用于可能接收外部token的strategy合约，并没有在其存入函数deploy中管理不同的decimal。（vault和strategy的decimal不对齐） | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-04-there-are-multiple-issues-with-the-decimal-conversions-between-the-vault-and-the-strategy) | ERC20                             | Strategy                                      | B      | checklist加上，外部资产mint shares之前或者burn之前，是否对齐decimal |
| 52   | `ERC20Permit`函数中的signature replay，没有验证msg.sender的身份，链上可以有人在发送者交易后，截取v,s,r抢跑将用户的钱转入Router合约，后通过`dispatch`中的sweepToken转入自己的口袋 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-05-the-implementation-of-pulltokenswithpermit-poses-a-risk-allowing-malicious-actors-to-steal-tokens) | signature replay                  | Strategy                                      | A      | 涉及签名的vrs一定要有额外验证，没有额外验证就是一个风险点    |
| 53   | 和上面有点类似，但是是由于 [`VaultRouter#execute()`](https://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiCommand.sol#L72-L87) 执行命令可以将用户approven的用户通过`PULL_TOKEN_FROM`转入Router，但是转出函数`PUSH_TOKEN_FROM`对象又没有管制，导致任意人可以先`PULL_TOKEN_FROM`将其他人的token转入合约，再`PUSH_TOKEN_FROM`转到自己口袋 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-06-malicious-actors-can-exploit-user-approved-allowances-on-vaultrouter-to-drain-their-erc20-tokens) | Access Control                    | Strategy                                      | B      | 没有加以管制的转入函数`PULL_TOKEN_FROM`和转出函数`PUSH_TOKEN_FROM` |
| 54   | 类似上面，不过这里是执行reedeem shares后再执行`PUSH_TOKEN_FROM`盗取用户的shares | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-07-malicious-actors-can-exploit-user-approved-allowances-on-vaultrouter-to-drain-their-erc4626-tokens) | Access Control                    | Strategy                                      | A      |                                                              |
| 55   | 不符合ERC4626的规范，导致的问题如：`maxDeposit`总是返回`type(uint256).max`，但是deposit相关的函数要检查这个limit，导致一个空洞且无用的检查，并且在pause状态下`maxDeposit`并不返回0 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-01-vaultbase-is-not-erc4626-compliant) | ERC4626                           | Strategy                                      | A      | 比较珍奇的bug，。规范问题值得列入checklist中                 |
| 56   | 管理多个strategy的逻辑中，当通过`addStrategy`来新加入一个`strategy`时，没有任何的给予新策略allowance的方法，导致新策略一直没钱进行获得 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-02-new-strategy-can-not-work-due-to-insufficient-allowance) | DoS                               | Strategy                                      | B      |                                                              |
| 57   | 在 `MultiStrategy.sol` 的 `removeStrategy` 函数中，移除一个有已部署（deployed）资产的杠杆策略时，合约按照 `strategyAssets = totalAssets()` 计算待撤出的资产量，再调用 `undeploy(strategyAssets)` 执行撤出，最后却仍以原始的 `strategyAssets` 数值重新分配给剩余策略（`_allocateAssets(strategyAssets)`）。对于杠杆策略而言，`undeploy` 中会通过 ERC-3156 标准的闪电贷（flash loan）借入债务、偿还并取出抵押、支付利息等操作，实际返还的资产往往 **少于** 请求撤出的数量[Code4rena](https://code4rena.com/reports/2024-12-bakerfi-invitational?utm_source=chatgpt.com)。这种不一致导致后续 `_allocateAssets` 尝试分配超过实际可用的资产量，从而使得“移除”操作在资金不足时失败，策略无法被删除，长期锁定了该条策略。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-03-multistrategyremovestrategy-cannot-remove-leverage-strategies-that-still-have-deployed-assets) | Logic error                       | Strategy                                      | B      |                                                              |
| 58   | 在 **VaultBase** 合约的 `_depositInternal` 方法中，只允许当 `totalAssets()` 与 `totalSupply()` 同时为零或同时为正时才可继续存款。然而，攻击者可在任意时机（包括首次存款之前或所有份额被提走后），**直接向底层 Strategy 合约转入代币**，使得 `totalAssets()` > 0 且 `totalSupply()` = 0，从而触发不匹配的状态检查，导致后续任何用户存款全都被 `InvalidAssetsState` 拦截，导致DoS | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-04-sending-tokens-to-a-strategy-when-totalsupply-is-0-can-permanently-make-the-vault-unavailable) | Donation Attack                   | Strategy                                      | C      |                                                              |
| 59   | DAI 使用 `permit` 时有兼容性问题，<br />正常的`IERC20Permit(token).permit(  address owner,  address spender,  uint256 value, uint256 deadline,  uint8 v, bytes32 r, bytes32 s);`<br/>而DAI中：<br />`permit(address holder,  address spender,  uint256 nonce,  uint256 expiry,  bool allowed,  uint8 v,  bytes32 r,  bytes32 s)` | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-05-permit-doesnt-work-with-dai) | ERC20                             | Strategy                                      | A      | 特殊ERC20 Permit案例                                         |
| 60   | modifier缺失，根据docs， `rebalance`本应该在pause的时候也暂停，但是实际上没有 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-06-even-when-the-vault-contract-is-paused-the-rebalance-function-is-not-paused) | Logic error                       | Strategy                                      | B      | 读文档，注意比如pause这个modifer的管辖范围                   |
| 61   | VaultBase 在内部存款逻辑 `_depositInternal` 中，对单个 `msg.sender` 的累计存款额设有 `_maxDeposit` 限制，但在检查时却错误地使用了 `balanceOf(msg.sender)` 而非接收者（`receiver`），攻击者可通过指定不同的接收地址多次存款而不增加自身余额，从而**无限绕过**最大存款上限。<br />正确的方法是使用mapping来检查而非`balanceOf(msg.sender)` | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-07-depositor-can-bypass-the-max-deposit-limit) | Logic error                       | Strategy                                      | B      | 检查没对齐导致的bypass                                       |
| 62   | 写错，导致action无法正常运行                                 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-08-the-dispatch-function-of-the-vaultrouter-does-not-work-as-intended-with-pull_token-action) | 写错                              | Strategy                                      | C      |                                                              |
| 63   | `VaultBase` deposit/mint/withdraw/redeem的函数都是`onlyWhiteListed`修饰的函数，防止未知地址收到得到shares与token，但是deposit中的receiver却没有做whitelist检查，这就bypass了whitelist check，这些非白名单用户通过`VaultRouter`就能进行shares的提现 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-09-non-whitelisted-recipient-can-receive-shares) | Logic error                       | Strategy                                      | B      | 一个非常隐蔽的bypass whitelist check，一旦有whitelist我们需要check，有没有类似的方法去绕过它 |
| 64   | 算是经典for循环中由于一个revert导致整个逻辑阻塞的案例，在这里只要有一个strategy的totalAsset为0，即`currentAssets[i]`=0，就会导致DoS | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-10-the-withdrawal-of-multi-strategies-vault-could-be-dosed-while-asset-deposits-remain-unaffected) | DoS                               | Strategy                                      | A      | for循环中出现revert的导致整个DoS的经典案例，对于for循环得DoS的注意 |
| 65   | 有点像我在[aegis-op-grant-CoheeYang](https://github.com/sherlock-audit/2025-04-aegis-op-grant-CoheeYang)中的发现，也是在一个`if(x>=y)`的比较中低估/高估了被比较数，这里则是在 `StrategySupplyMorpho.sol` 中，`_undeploy` 函数为确定“最大可撤出资产”（`assetsMax`）直接使用了合约存储的 `totalSupplyAssets` 与 `totalSupplyShares`，却忽略了自上次更新以来在 Morpho 协议中已累计的利息和费用，因此 `assetsMax` 被系统性**低估**。当用户请求提现量 `amount` 超过该低估的 `assetsMax` 时，合约会走到“全额赎回”分支，将策略中所有份额全部转换并返还给用户，导致他们不仅提取了自己的利息收益，还拿走了**其他用户**的本金和利息，形成对剩余份额持有者的严重损失风险 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-11-the-calculation-of-assetsmax-is-incorrect) | Logic error                       | Strategy                                      | A      | 有点像我在[aegis-op-grant-CoheeYang](https://github.com/sherlock-audit/2025-04-aegis-op-grant-CoheeYang)中的发现，也是在一个`if(x>=y)`的比较中低估/高估了被比较数 |
| 66   | 和之前for循环中一个revert全部revert一样，这里是由于for循环中一个外部三方pause导致call无法进行withdraw，从而导致全部for循环中的都revert掉。<br />这里给了我们新的revert的洞察，值得一看 | [BakerFi]()                                                  | DoS                               | Strategy                                      | A      | For循环中，没有continue的都得注意，外部三方的revert也可能成为严重的DoS。 |
| 67   | `MultiStrategyVault`仅剩最后一个strategy时，`removeStrategy` 函数在更新完 `_totalWeight` 并清空该策略权重后，还未将策略从数组中移除，就会调用 `_allocateAssets` 对所有（此时仅剩的）策略按新权重重新部署资产。由于此时 `_totalWeight == 0`，在计算 `(amount * _weights[i]) / _totalWeight` 时会触发“除以零”错误（panic: division or modulo by zero），导致最后一个策略**永远无法被移除**。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-13-the-vault-manager-is-unable-to-delete-the-last-strategy-from-multistrategyvault) | Logic error                       | Strategy                                      | A      | 有点争议，但是极值确是是一个比较好的思路                     |
| 68   | 最奇特的bug发现，即constructor中的asset与后续的`loanTokens`不一样就会造成合约不可用。<br />我觉得很扯淡，但是这确实算进去了 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-14-the-strategysupplymorpho-allow-to-use-wrong-token-in-_asset) | Logic error                       | Strategy                                      | B      | 最奇特的bug发现                                              |
| 69   | 混乱的调用关系，如果使用VaultRouter进行deposit，那么maxDepositLocal的检查将会很轻易地revert，因为`_depositInternal`检查的是msg.sender的balance，即router的balance，而不是用户的 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-15-vaultrouter-cannot-be-used-for-deposits-when-it-reaches-the-maximum-deposit-limit) | Logic error                       | Strategy                                      | B      |                                                              |
| 70   | 纯写错                                                       | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-16-strategysupplybaseundeploy-does-not-return-the-amount-of-assets-actually-undeployed-which-can-cause-a-withdrawal-to-fail) |                                   |                                               |        |                                                              |
| 71   |                                                              | [Nibiru](https://code4rena.com/reports/2024-11-nibiru#h-01-vesting-account-preemption-attack-preventing-future-contract-deployment) |                                   | L1 chain (Go)                                 |        |                                                              |
| 72   | 在 外部的一个关于``sparse binary Merkle Patricia Trie`项目Scroll zkTrie 的设计文档中，为避免密钥表示在有限域（Poseidon 哈希所在域）中出现二义性，需要限制树的最大深度为 248 位（即最多遍历键的低 248 位）。但在 `ScrollVerifierHooks.sol` 的一个遍历该MP树的函数 `walkTree` 实现中，主循环里并未加入任何深度上限检查 | [Unruggable](https://code4rena.com/reports/2024-12-unruggable-invitational#m-01-zktrie-maximum-depth-limit-is-not-enforced-in-scroll) | Logic error                       | ENS                                           | A      | 算法问题，注意看文档和了解基础算法                           |
| 73   | 在 项目中`OPFaultVerifier.sol` 的 `getStorageValues` 方法中，验证逻辑调用了 Optimism Portal（`IOptimismPortal`）提供的游戏查询接口，却**未检查该游戏是否已被 Guardian 黑名单化**。而在 Optimism Portal 的设计中，一旦游戏因“错误解析”被黑名单化，就意味着该游戏的结果不可信，任何基于此游戏的后续状态证明都应被拒绝。 | [Unruggable](https://code4rena.com/reports/2024-12-unruggable-invitational#m-01-zktrie-maximum-depth-limit-is-not-enforced-in-scroll) | Logic error                       |                                               | A      | 这类bug是在外部调用合约中非常常见的，比如一个staking项目中（mystic finance）对validator有active检查，却少了slashed检查。这种状态变量可能是单纯的值类型，也可能是struct类型和mapping,在这里就是少忽略了`blackListed`的mapping的检查 |
| 74   | 在 Starknet 端cairo文件的 `receive_cross_chain_msg` 实现中，并违反了项目文档中“跨链消息只能被接收一次”的核心不变量。由于缺失对已处理交易状态 `CrossChainMsgStatus.Unknow` 的检查，任何人均可重复提交已成功并有效的交易参数，进而多次执行相同的跨链消息，造成资产二次发放或协议状态混乱[Code4rena](https://code4rena.com/reports/2024-08-chakra?utm_source=chatgpt.com)。攻击者无需持有私钥或额外权限，只需重放已知参数即可获利 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-02-in-starknet-already-processed-messages-can-be-re-submitted-and-by-anyone) | Access Control                    | Bridge (BTC cross chain)                      | C      |                                                              |
| 75   | `ChakraSettlement` 合约中的 `nonce_manager` 映射被设计为 `mapping(address ⇒ uint256)`，并在外部可调用的 `send_cross_chain_msg` 中对任意 `from_address` 进行自增，导致攻击者可“替他人”增加 nonce，从而使处理跨链交易时生成的 `txid` 与预期不符，破坏系统对交易 ID 的一致性和安全假设。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-07-anyone-can-manipulate-user-nonce-nonce_manager-in-settlement-contract) | Access Control                    | Bridge                                        | C      |                                                              |
| 76   | bridge后settle中的函数`receive_cross_chain_msg`中未`payload`包含进消息哈希的生成与签名验证流程里。而`payload`这个输入会被emit给链下机器人执行相对应的任务，如果有人抢跑了签名，并修改对应的payload，则会导致错误的任务被执行。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-08-in-settlementcairoreceive_cross_chain_msg---the-payload_type-can-be-passed-by-the-user-confusing-offchain-systems) | Signature Replay                  | Bridge                                        | A      | 非常复杂的bug，是链上emit的信息被它人修改后由链下机器人接收。<br />本质上过于宽松的签名处理，签名没有包括所有的要emit内容。 |
| 77   | 不同版本的`receive_cross_chain_callback`，对同样的行为做出了不同的动作，cairo会revert非白名单handler发来的交易，而solidity则返回false。前者会将处于`CrossChainMsgStatus.Pending`交易卡住，导致DoS。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-09-inconsistent-handler-validation-behavior-in-cairo-erc20handlers-cross-chain-callback) | Logic error                       | Bridge                                        | A      | 系统内多个脚本处理的不一致导致的问题<br />系统流程搞清楚非常重要 |
| 78   | 多个函数中的校验签名时同样**不包含**任何链ID的信息，导致如果CREATE2 或同一密钥得到不同链上的相同合约地址时，若 to_chain A 和 B 上的 Validator 集合、Handler 地址、白名单配置均相同，则 A 链签署的跨链消息同样能在 B 链被视为合法 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-10-chakrasettlementreceive_cross_chain_msg-and-chakrasettlementreceive_cross_chain_callback-functions-do-not-ensure-that-receiving-chakrasettlement-contracts-contract_chain_name-must-match-to_chain-corresponding-to-respective-txid-input-though-they-should) | Signature Replay                  | Bridge                                        | A      | 跨链中的校验签名在不同链上的复用。                           |
| 79   | 结算系统中的handler缺乏refund机制，导致跨链交易失败后会产生资金丢失。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-11-there-is-no-refund-mechanism-in-chakrasettlementprocesscrosschaincallback-or-chakrasettlementhandlerreceive_cross_chain_callback-function) | Logic error                       | Bridge                                        | A      | Bridge中，从链A到B，需要将A中的token进行lock/burn/transfer，再经过系统验证后再到B链上生成对应的token。<br />但是万一中间过程失败了怎么办？失败了应该有refund机制将原A链的token还给user，但是这里却没有，而是直接返回fail的信息而已。 |
| 80   | Lock和Mint的方法用反了                                       | [chakra](https://code4rena.com/reports/2024-08-chakra#h-13-the-lockmint-and-burnunlock-modes-cannot-be-used) | Logic error                       | Bridge                                        | A      | 这个问题看上去很简单，但是却很少人发现。                     |
| 81   | Hans 发现的bug，非常有意思。<br />具体而言是一个swap换钱的合约中，swap中的手续费会当成LP的奖励直接distribute。问题出现于交易顺序，它是先distribute再将caller的钱转进来，一开始因为有存储所以没问题但是到了后面存储用完就会因为资金耗尽而revert | [Upside](https://github.com/code-423n4/2025-05-upside/blob/main/2025-05-16-hans-upside-v4.pdf) | Logic error                       | Tokenization Platform                         | A      | 交易顺序！                                                   |
| 82   | 在一般的vault中 mint/deposit 时计算要给用户铸造的份额<br/>` shares == 0? Amount: Amount* totalShares / totalAssetsInContract`<br/>Attacker可以先mint 1wei的shares，再人为转账到合约如`1000e18-1`的token，使得`totalShares/totalAssets`极度容易decimal loss。<br/> 当用户 redeem/burn 时，根据其份额计算能取出的资产<br/>`tokens = shares * totalAssetsInContract / totalShares`<br />此时其他任何的用户存入只要decimal loss，attacker就可以白嫖它们存入的钱。 | [PoolTogether](https://solodit.cyfrin.io/issues/h-01-a-malicious-early-userattacker-can-manipulate-the-vaults-pricepershare-to-take-an-unfair-share-of-future-users-deposits-code4rena-pooltogether-pooltogether-git) | PPS Manipulation                  | Strategy                                      | B      | Inflation Attack的根源在于使用`balanceOf(this)`计算的资产数量，最佳其实应该使用一个mapping进行记录，或者在一开始就人为地存入钱 |
| 83   | Silo vault是一个聚合vault，将用户存入的钱按策略来存入到其他各种market vault中以获取利润。<br />然而在deposti到其他vault的逻辑中，一个for循环只是单纯的进行存入动作，而没有考虑market.vault的`maxDeposit`.这就导致了可能vault1和vault2剩下的总余额够`siloVault`存，但是单次存入的余额却不够而无法成功分配资金。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-01-supply-function-doesnt-account-for-market-maxdeposit-when-providing-assets-to-it) | ERC4626                           | Lending                                       | B      | 聚合vault存入其他多个vault前，没有检查其他vault的总余额而按情况进行分配。 |
| 84   | 在分配手续费中，Silo finance选择在每次用户操作时使用`_accrueFee()`来给`feeRecipient`铸造一些vault shares来获取底层资产利息的增值。<br />在`claimRewards()`中先调用 `_accrueFee()`以保证`feeRecipient`的shares被mint了，从而再执行`_claimRewards()`来进行合理的分配。<br />但是在`_update()`中却缺少了`_accrueFee()`而直接执行了`_claimRewards()`，这样用户可以通过`transfer/transferFrom`直接claim，而绕开手续费。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-02-silovault-will-incorrectly-accrue-rewards-during-user-transfertransferfrom-actions-due-to-unsynced-totalsupply) | Logic error                       | Lending                                       | B      | 手续费分配机制的缺失，导致潜在的bypass使得`feeRecipient`的利益受损 |
| 85   | Remove market要求将token的approve设置为0，然而有些如BNB币approve zero会revert，从而无法移除该vault. | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-03-silovaultsol--markets-with-assets-that-revert-on-zero-approvals-cannot-be-removed) | ERC20                             | Lending                                       | A      | approve设为0时会revert的bug。Wired ERC20                     |
| 86   | 聚合器vault的`deposit/redeem`是和多个市场vault进行交互，却没有slippage protection/deadline.<br />这就导致一旦底层 market 在交易执行之前或中途发生价格波动，用户就可能获得少于预期的 Vault Share。同理，在 `withdraw()` 或 `redeem()` 时，如果某个 market 流动性不足、迫使合约转移到下一个 market，那下一个 market 的兑换率可能更差，最终用户实际拿到的底层资产就会比他提交时预期的少。<br />同时没有设置`dealline`，交易可能卡在memepool中，最后交易会在一个unfavored price成交。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-04-lack-of-slippage-and-deadline-protection-in-deposit-withdraw-and-redeem) | Logic error                       | Lending                                       | B      | Slippage protection不光得需要在诸如AMM的`swap()`中有，也需要在这样的聚合器中有，防止价格走势影响用户的利益。<br />凡是价格/时间敏感的都得注意`slippage`和`deadline` |
| 87   | `claimRewards()`在计算`feeRecipient`的份额时，调用`_accrueFee()`会mint给其一定的shares，但是mint同时会触发`update()`从而触发`_claimRewards()`,使得caller回收奖励。<br />但是问题就在于执行顺序上，此时触发`_claimRewards()`并没有调用`super.update`更新`feeRecipient`的shares，使得此次的claim并不会让新mint的shares被考虑进去，从而让feeRecipient利益受损，而user获得更多rewards | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-05-incorrect-reward-distribution-due-to-feeshares-minting-order) | Logic error                       | Lending                                       | S      | 更新顺序得注意                                               |
| 88   | 类似inflation attack，由于存入资产mint的share由`_assets.mulDiv(_newTotalSupply + 10 ** _decimalsOffset(), _newTotalAssets + 1, _rounding)`计算而来，存入1wei，会使得mint `1*10e18/1`（假设offset=18），但是实际资产没有增加，因为1wei存到其他market中会直接由于decimal loss掉。反复如此shares狂增而asset没有增加。<br /> | [SiloFinance]()                                              | PPS Manipulation                  | Lending                                       | S      | 其实主要是这个bug是因为没有资产被增加，shares却增加了invariant被打破了。即使如此我们要得思考类似的产生大数的情况，比如存入1e18可能就会mint 1e36的情况。会不会超过uint256最大值。 |
| 89   | YUSD 是一个以“抵押品”（collateral）为支持、可在链上 mint（铸造）和 redeem（赎回）的稳定币。通常，用户先用某种抵押资产（例如 USDC、DAI 等）在 `mint()` 函数中铸造等值的 YUSD；之后，当用户想要赎回时，会提交一个赎回请求（RedeemRequest），等待由持有 `FUNDS_MANAGER_ROLE` 的角色调用 `approveRedeemRequest()` 来完成赎回：把用户先前抵押的资产退给他们，并销毁等量的 YUSD。<br />报告指出，在 `approveRedeemRequest()` 的流程中，协议将「全额抵押物」直接返还给用户，但同时会按照赎回金额（`yusdAmount`）抽取一笔手续费（redeem fee），把这笔手续费以 YUSD 形式发往insurance fund，并销毁剩余 YUSD。由于退款时退回的抵押物数量是按“赎回前的 YUSD 总额”来算，而手续费部分对应的 YUSD 并未在之前为其预留抵押品，就造成「未被任何抵押物支持的 YUSD」存在。这些未被抵押品覆盖的 YUSD 是可以再用来赎回抵押物的，久而久之，协议里的抵押品储备就会被一点一点提光，导致 YUSD 与美元挂钩的稳定性（peg）崩塌——也就是“去锚”（depeg） | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | Logic error                       | Stable Coin                                   | B      | 稳定币存在脱锚的情况，即出现了没有抵押物但是mint了coint的存在 |
| 90   | Aegis 协议的 minting 合约（AegisMinting.sol）本意是“自持无余”，即所有用户在 mint YUSD 时上链的抵押品，都会立即转给外部的托管方（custodial partners）保管；当用户赎回 YUSD 时，协议再从托管方提回对应的抵押品给用户。按照官方叙述，mint 合约本身不应长期持有用户抵押的资产，交易过程中的资金流向应当是“用户→合约→托管方（mint 时）”以及“托管方→合约→用户（redeem 时）”。<br />但是，报告指出，在现实使用中，以下两种资金状态会被“未追踪”（untracked）地滞留在 mint 合约中：<br />**待赎回（pending）但最后未执行的赎回请求对应的抵押品**。即：当用户发起赎回，协议从托管方提回抵押品到合约后，因多种原因（如用户取消赎回、订单过期、slippage 导致验资失败、黑名单限制等）赎回请求最终没有被批准，已提回的抵押品就会卡在合约里。 <br />**将其视为“协议收益（profit）”时，可能会调用 `depositIncome` 把这些卡住的fund当作新增收入并铸造 YUSD**，从而导致部分 YUSD 并没有相应抵押品支持。 | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | Logic error(记账混乱)             | Stable Coin                                   | S      | 本质原因是由于redeem的两个非连续的步骤，中间如果没成功。<br />同时穿插了其他`balanceOf(this)`的accounting记账，导致的记账混乱，错误地记成了收入。 |
| 91   | Aegis 协议中为了限制单个周期内的铸造（mint）和赎回（redeem）总量，引入了一个“周期限额”（MintRedeemLimit）机制。其核心思路是： **限额配置**  每个周期（`periodDuration`，例如 24 小时）都有一个最大可赎回 YUSD 总量：`redeemLimit.maxPeriodAmount`。 **实时计数器**  当有人发起赎回请求（`requestRedeem`）时，会检查当前这一周期里已提交（或“占用”）的赎回总量 `limits.currentPeriodTotalAmount`，确保它与本次请求量相加不超过 `maxPeriodAmount`。如果超过，则交易会 revert（抛出 `LimitReached` 错误）。 **周期刷新**  当距离上一次记录超过 `periodDuration` 时，合约会将 `limits.currentPeriodTotalAmount` 重置为 0，开启新一轮的周期计算。  <br />正常情况下，用户发起赎回请求时，便先“占用”一定额度；如果请求最终成功、或最终失败（被拒绝或撤销），就应该相应地“释放”这部分额度，保证限额对所有用户公平生效。<br />**然而，Issue M-2 发现：当前合约在“用户撤销赎回”或“赎回被拒绝”时，并没有把之前在 `currentPeriodTotalAmount` 中累加的额度扣回。**换言之，只要用户（或恶意鲸鱼）发起了一笔赎回，就把额度算进去了；即便后来撤销，额度依旧保持占用状态，直到周期结束才自然清零。由此，鲸鱼即可通过批量发送赎回请求，然后在它们过期后逐一撤销，令这一周期内的 `currentPeriodTotalAmount` 维持在一个极高值或逼近上限，从而让同周期内其他用户无法再发起新的赎回——形成了“赎回功能被恶意阻塞（griefing）”的局面。 | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | DoS                               | Stable Coin                                   | B      | 这是一个关于限额的问题，即如果有人恶意用掉了限额会不会产生DoS。 |
| 92   | 合约允许用户通过`overrideReceiver()`将现有的奖励收款账户转移成另一个。并调用`_migrateRewards(msg.sender, overrideAddress)`将现在记录的奖励转给新地址。<br />于此同时`removeOverrideAddress()`，又可以调用`_migrateRewards(overrideAddresses[msg.sender], msg.sender)`，将之前的override换成msg.sender账户。<br />这样一来一回，可以将其他人的高奖励账户的reward换成自己的。 | [mev-commit](https://cantina.xyz/code/e92be0b9-b4f2-4bf2-9544-ae285fcfc02d/findings/15) | Logic error                       | MEV                                           | B      | 狸猫换太子                                                   |
| 93   | 当向外部转账，有人可以使用没写receive/fallback的合约来导致潜在的DoS | [GuardianAuditor](https://lab.guardianaudits.com/encyclopedia-of-solidity-attack-vectors/contract-cannot-accept-ether-dos) | DoS                               |                                               |        | Unpayable DoS                                                |
| 94   |                                                              |                                                              | Signature malleability            |                                               |        |                                                              |
| 95   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 96   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 97   |                                                              |                                                              |                                   |                                               |        |                                                              |
| 98   |                                                              |                                                              |                                   |                                               |        |                                                              |





## Check list

deposit/withdraw: 

前置check是否正确处理，

比如检查了最大存/取额度（可能是vault中的token有限，不能存取超过最大额度）

是否有period limit（不允许的period用于无法存取）

是否正确处理了角色（attack是否能存/取别人的钱？）

0值是否会导致问题？比如存0但是取不为0

是否有存款，withdraw的所产生的array push导致dos ?（快速发送大量存取信息导致其他用户无法正常存取）

是否有flash-deposit获利的情况





## Classification from solodit


| Title                            | **Description**                                              |
| -------------------------------- | ------------------------------------------------------------ |
| 0x                               | 0x Protocol is the trusted open source settlement layer for the permissionless global exchange of value. |
| 1/64 Rule                        | According to this rule, when a contract function makes a call to another function or contract, only 63/64 of the remaining gas can be forwarded in a message call |
| 51% Attack                       | An attack on a cryptocurrency blockchain by a group of miners who control more than 50% of the network's mining hash rate. Owning 51% of the nodes on the network gives the controlling parties the power to alter the blockchain. |
| Aave                             | Aave is a decentralized cryptocurrency platform that allows users to borrow and lend crypto. Aave uses smart contracts to automate the process, with preset rules on how funds are distributed, how collateral is handled, and how fees are assessed. |
| ABI Encoding                     | Encoding functions can be used to craft data for external function calls without actually calling an external function. Furthermore, keccak256(abi.encodePacked(a, b)) is a way to compute the hash of structured data (although be aware that it is possible to craft a “hash collision” using different function parameter types). |
| Access Control                   | Access control vulnerabilities are cases where a smart contract does not properly restrict the use of certain operations to authorized users. These vulnerabilities can arise from excessively permissive or overly restrictive access controls. They are critical because they may allow unauthorized users to manipulate contract data or operations. |
| Account Abstraction              | Account Abstraction in Ethereum aims to enhance user interactions by allowing greater flexibility in how transactions and smart contracts are initiated. It proposes upgrading externally owned accounts (EOAs) to be controlled by smart contracts or enabling smart contracts to initiate transactions. |
| Add/Subtract Match               | Calculations involving addition and subtraction are not synchronized or consistent, leading to unexpected outcomes. |
| Admin                            | Admin vulnerabilities typically involve scenarios where an administrator, who holds special permissions, could potentially misuse their authority to manipulate settings, parameters, or functionalities in a way that could be detrimental to the system's integrity or fairness. |
| Airdrop                          | Airdrop vulnerabilities refers to a potential risk associated with the distribution of tokens or assets to multiple addresses. This vulnerability arises when the process lacks proper validation or authorization checks, potentially allowing unauthorized recipients to gain access to the airdropped tokens, leading to loss or misuse of resources. |
| Allowance                        | Allowance vulnerability arises when a user grants excessive spending permissions to a third-party address, potentially allowing unauthorized access to their tokens and enabling malicious actions. Allowances are necessary in Ethereum to enable certain functionalities like decentralized exchanges or lending platforms, where smart contracts need limited access to a user's tokens for specific operations, but if not properly managed, it can lead to security risks. |
| API Inconsistency                | API inconsistency vulnerabilities are present when the functions within a smart contract have inconsistent calling patterns or semantics. Although the individual functions may be implemented correctly, the inconsistency in how they are used or interact with each other could confuse users or developers, potentially leading to mistakes or misuse of the contract. |
| Approve                          | Approve refers to a function in Ethereum smart contracts that allows a token holder to grant spending permissions to another address. This action can become a vulnerability if not carefully managed, potentially leading to unauthorized access and misuse of the approved tokens by the designated address. |
| Approve Max                      | Approve Max refers to a potential risk associated with setting the approval amount to the maximum possible value (often 2^256 - 1) when interacting with smart contracts. |
| Arbitrum                         | Arbitrum is a technology suite designed to scale Ethereum. You can use Arbitrum chains to do all things you do on Ethereum — use Web3 apps, deploy smart contracts, etc., but your transactions will be cheaper and faster. |
| Array                            | Array refers to a data structure that holds multiple elements under a single variable name. Vulnerabilities related to arrays can arise when developers do not properly handle array indices or fail to validate user inputs. |
| Array Bound                      | Array Bound refers to the potential risk of accessing or modifying elements in an array outside the specified range of indices. This vulnerability can occur if proper checks and validations are not implemented. |
| Array Reorder                    | Array Reorder refers to the risk associated with the manipulation of array elements' order, potentially leading to unintended consequences or exploitable conditions. |
| Assembly                         | Assembly refers to a low-level programming language feature in Solidity that allows developers to directly interact with the Ethereum Virtual Machine (EVM). |
| Auction                          | Auction refers to a system where goods or services are sold to the highest bidder. Vulnerabilities can arise in auctions when there are flaws in the bidding process, such as incorrect validation of bids, improper handling of time constraints, or lack of transparency, potentially leading to unfair practices or exploitation by malicious actors. |
| Auditing and Logging             | Auditing and logging vulnerabilities are characterized by insufficient or incorrect logging mechanisms within a smart contract. These vulnerabilities make it difficult to monitor and audit contract activities. |
| Authentication                   | Authentication vulnerabilities are cases where the mechanism used to verify identity or authorization is flawed. This is different from access control issues; here, the logic regarding who can do what is correct, but the system fails in accurately determining the identity of participants. |
| AutoRoll                         | AutoRoll is an ERC4626 compliant vault that simplifies the process of managing liquidity pools by automatically migrating it from a matured series to a new one. It offers LPs a passive experience, where they can deposit their assets, receive LP shares, and have their holdings automatically transitioned to a new series with a starting market rate after a "cooldown" period following maturity. |
| Blacklisted                      | Blacklisted mostly refer to cryptocurrency wallets that have been flagged or identified as associated with illicit activities or known scams. These wallets are typically subject to restrictions to prevent their involvement in fraudulent transactions or criminal operations within the cryptocurrency ecosystem. |
| block.number vs block.timestamp  | block.number refers to the unique identifier of a block within a blockchain, representing its position in the chain's chronological order. On the other hand, block.timestamp denotes the specific time at which a block is mined, recorded as a Unix timestamp, providing a reference point for time-based operations within a smart contract. |
| Block Period                     | Block Period usually refers to a specific period of time measured in blocks. This term is crucial in understanding time-related functions and vulnerabilities in smart contracts, as it helps determine when certain actions or conditions can occur based on the passage of blocks. |
| Bond                             | Bond Protocol is a permissionless product suite for optimizing DAO treasuries and token economics |
| Brick                            | brick is a term used to describe a type of malicious contract or code that is intentionally designed to disrupt or harm the Ethereum network. This can include contracts with excessive gas consumption, causing network congestion, or those designed to exploit vulnerabilities in other contracts, potentially leading to financial losses for users. |
| Bridge                           | Bridge refers to a smart contract or mechanism that facilitates the interoperability between different blockchain networks. While bridges are essential for cross-chain functionality, they can introduce security risks if not properly implemented, potentially allowing for exploits or vulnerabilities that could affect the integrity of assets transferred between blockchains. |
| Broken Loop                      | Broken Loop refers to a loop lacks a proper exit condition, causing it to execute indefinitely. This can lead to excessive gas consumption, potentially resulting in a denial-of-service attack on the Ethereum network or causing a contract to become unresponsive. |
| Business Logic                   | Logic vulnerabilities involve flaws in the business logic or protocols of a smart contract, where the implementation matches the developer's intention, but the underlying logic is inherently flawed. |
| Bypass limit                     | Bypass limit refers to a scenario where a smart contract or function lacks proper checks and allows users to exceed predefined limits or constraints. |
| Calldata                         | Calldata refers to the area where function arguments and data are stored when a contract is called from an external source. It is a read-only area, meaning that the data stored here cannot be modified by the contract itself |
| call vs transfer                 | Use 'call' instead of 'transfer' due to gas cost considerations, and make sure to implement the CEI pattern to prevent reentrancy vulnerabilities when utilizing 'call'. |
| Can't Remove Access Control      | Refers to a situation where a smart contract lacks a mechanism to revoke or modify access permissions once they have been granted. |
| CEI                              | Checks effects interactions patterns is an effective way to prevent reentrancy attacks in a smart contract code. The first step in using this pattern is to perform some checks and verifications in the contract flow. |
| Chain ID                         | Chain ID refers to a unique identifier assigned to a specific blockchain network. It is a critical parameter for ensuring secure interactions between different chains, helping prevent attacks that attempt to manipulate transactions meant for a particular chain. |
| Chainlink                        | Chainlink is a decentralized blockchain oracle network. The network is intended to be used to facilitate the transfer of tamper-proof data from off-chain sources to on-chain smart contracts. |
| Chain Reorganization Attack      | Chain Reorganization Attack occurs when a malicious actor gains control over a significant portion of a blockchain's mining power, allowing them to create an alternate version of the blockchain that replaces the existing one. |
| Change Validation                | Change Validation refers to the process of verifying and validating modifications to critical parameters or functionalities within a smart contract. It is essential for ensuring that alterations are made securely and in compliance with the contract's intended behavior. |
| CheckPoint                       | CheckPoint is a specific point in a blockchain's history that is recorded and used as a reference for security and validation purposes. It serves as a snapshot of the blockchain's state at a particular moment. |
| Check Return Value               | Check Return Value refers to the practice of validating and handling the result or return value of external function calls. |
| Code Quality                     | Code quality issues pertain to the readability and maintainability of the smart contract code. These are not directly related to the functionality of the contract but can have long-term impacts on the ability to understand, maintain, and securely update the code. Code quality is considered to be a non-functional requirement but is essential for the sustainability and reliability of a smart contract. |
| Coding-Bug                       | Coding-bug is a broad category that covers simple mistakes in the code, akin to typos, which can lead to unintended behavior. These are usually unintended errors rather than deliberate logic errors. |
| Collateral Factor                | Collateral Factor pertains to the ratio determining the amount of collateral required to back a specific asset in decentralized finance (DeFi) protocols. |
| Configuration                    | Configuration vulnerabilities arise from improper configuration of a smart contract which, despite having correct code, leads to unintended behavior. This is common in cases where financial parameters or market settings are misconfigured. |
| Constructor                      | Constructor is a special function within a smart contract that is executed only once when the contract is deployed. It is responsible for initializing the contract's state variables and can play a crucial role in ensuring the secure and intended behavior of the contract upon deployment. |
| Cooldown                         | Cooldown refers to a mechanism implemented in smart contracts to introduce a delay or waiting period before certain actions can be performed. |
| CREATE2                          | CREATE2 is an opcode that allows for the creation of smart contracts with a deterministic address based on the contract's bytecode and initialization parameters. |
| Cross Chain                      | Cross Chain refers to interactions or transactions that occur between different blockchain networks. This introduces a unique set of security considerations, as smart contracts must implement measures to validate and handle cross-chain interactions securely. |
| Cross Chain Message              | Cross Chain Message refers to a communication or transaction initiated on one blockchain network that is intended to interact with or trigger actions on a different blockchain. |
| Cryptography                     | Cryptography vulnerabilities occur when a smart contract employs flawed or insufficient cryptographic practices. In the context of blockchain and smart contracts, this often involves the use of weak or inappropriate algorithms for tasks such as generating random numbers. The use of improper cryptography can compromise the security and integrity of a smart contract. |
| CryptoPunks                      | CryptoPunks is a non-fungible token collection on the Ethereum blockchain，launched as a fixed set of 10,000 items in mid-2017 and became one of the inspirations for the ERC-721 standard. |
| Data Exposure                    | Data exposure vulnerabilities occur when sensitive data that should remain private is inadvertently made public by the smart contract, often through transactions or blockchain state. |
| Data Validation                  | Data validation vulnerabilities arise when a smart contract does not adequately verify or sanitize inputs, especially those from untrusted sources. This lack of validation can lead to unintended and potentially harmful consequences within the contract’s operations. |
| DAO                              | A decentralized autonomous organization (DAO) is an emerging form of legal structure that has no central governing body and whose members share a common goal to act in the best interest of the entity. Popularized through cryptocurrency enthusiasts and blockchain technology, DAOs are used to make decisions in a bottom-up management approach. |
| Deadline                         | Deadline refers to a specified timestamp or block number by which a certain action or transaction must be completed. It serves as a critical security measure to enforce time-sensitive operations within a smart contract. |
| Decimals                         | Decimals refers to the level of precision used to represent fractional values of tokens within a smart contract. Incorrectly setting or manipulating decimal values can lead to miscalculations in token amounts. |
| Delegate                         | Delegate typically refers to the practice of delegating or forwarding certain functions or permissions to another smart contract or external address. |
| Denial-Of-Service                | Denial of Service (DoS) vulnerabilities occur when an attacker can exploit a contract in a way that makes it unresponsive or significantly less efficient. This category includes cases that are not well described by another class and where the primary consequence is contract shut-down or operational inefficiency. |
| Deposit/Reward tokens            | Deposit/Reward tokens pertain to the process of placing assets into a smart contract, often as part of a staking or yield farming mechanism, in order to earn rewards or benefits. |
| Diamond                          | Diamond refers to a design pattern that allows for the efficient and upgradeable deployment of multiple functionalities within a smart contract system. |
| Documentation                    | Documentation vulnerabilities aren't issues in the smart contract code itself, but rather in the accompanying documentation. This category includes cases where the documentation is incorrect, unclear, or incomplete. While documentation issues generally don’t affect the execution of the contract, they can lead to misuse or misunderstanding of how the contract should be used, which can indirectly contribute to security issues. |
| Domain Separator                 | The domain separator, in the context of EIP-712, is a cryptographic value that uniquely identifies a specific domain or dapps. It is used to prevent replay attacks and ensure that structured data is signed within the correct context. |
| Don't update state               | Don't update state refers to a guideline that advises against modifying the contract's state or storage within certain functions, as doing so may lead to unintended consequences for users and other contracts interacting with it. |
| DOS                              | DOS stands for Denial-of-Service, which refers to a malicious attack aimed at disrupting or preventing the normal functioning of a smart contract or blockchain network. |
| Dust                             | Dust refers to very small or negligible amounts of cryptocurrency, often below the precision threshold of a token's decimals. These tiny balances can accumulate in wallets or contracts and, if not managed properly, may lead to inefficiencies, increased gas costs, or even potential vulnerabilities in smart contracts. |
| ECDSA                            | ECDSA stands for Elliptic Curve Digital Signature Algorithm. It is a combination of the Digital Signature Algorithm (DSA) and Elliptic Curve Cryptography (ECC). The DSA uses the keys derived from the ECC and is a very efficient equation based on Public Key Cryptography (PKC). |
| ecrecover                        | ecrecover is a crucial Ethereum Solidity function that allows a smart contract to verify digital signatures. It takes a message, a signature, and the signer's public key, and returns the address that corresponds to the private key used for signing, providing a means to authenticate external messages in a smart contract. |
| EIP-1271                         | EIP-1271, also known as the "Standardized Contract Signatures," is an Ethereum Improvement Proposal that defines a standard way for smart contracts to validate the authenticity of a message or transaction. It allows contracts to implement a specific function, isValidSignature, which can be used to verify signatures. |
| EIP-150                          | EIP-150, also known as the "Gas cost changes for IO-heavy operations", aimed to make certain computational operations more expensive in terms of gas, discouraging potential attackers from exploiting vulnerabilities related to excessive gas consumption. |
| EIP-165                          | EIP-165, known as the "Standard Interface Detection", outlines a standardized way for smart contracts to declare which interfaces they support. This allows other contracts and applications to interact with them more securely by verifying their capabilities before attempting any transactions. |
| EIP-2981                         | EIP-2981, titled "NFT Royalty Standard", provides a standardized way for non-fungible tokens (NFTs) to handle royalty payments to creators when they are resold. |
| EIP-4337                         | EIP-4337 is an account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure. |
| EIP-4524                         | EIP-4524 "Safer ERC-20" standard extends ERC-20 tokens with EIP-165, and adds familiar functions from ERC-721 and ERC-1155 ensuring receiving contracts have implemented proper functionality. |
| EIP-4626                         | EIP-4626 "Tokenized Vaults" allows for the implementation of a standard API for tokenized Vaults representing shares of a single underlying EIP-20 token. This standard is an extension on the EIP-20 token that provides basic functionality for depositing and withdrawing tokens and reading balances. |
| EIP-4758                         | EIP-4758, titled "Deactivate SELFDESTRUCT", renames the SELFDESTRUCT opcode to SENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller. |
| EIP-712                          | EIP-712, also known as "Typed Structured Data," introduces a standardized way to create and validate messages that need to be signed by external accounts or contracts. |
| Emergency                        | Emergency refers to a situation within a smart contract that enables users to forcefully withdraw their funds in critical situations. This function is usually designed to bypass specific checks or restrictions, providing a fail-safe mechanism to ensure users can recover their assets even in abnormal circumstances. |
| EOA                              | An EOA refers to a standard Ethereum account controlled by a private key and is not associated with any smart contract code. It is primarily used for transactions on the Ethereum network and does not possess the ability to execute complex code logic like a smart contract account. |
| ERC1155                          | ERC1155 refers to a widely-used Ethereum token standard that allows for the creation of multi-fungible tokens. Unlike traditional ERC20 or ERC721 tokens, ERC1155 tokens can represent multiple types of assets within a single contract |
| ERC20                            | ERC-20 is the technical standard for fungible tokens created using the Ethereum blockchain. A fungible token is interchangeable with another token—where the well-known non-fungible tokens (NFTs) are not interchangeable. |
| ERC2981                          | ERC2981 known as "NFT Royalty Standard." It introduces a standardized way to handle royalty payments for non-fungible tokens (NFTs) on the Ethereum blockchain, providing a mechanism to ensure creators receive a share of the proceeds when their NFTs are resold. |
| ERC4626                          | ERC-4626 "Tokenized Vaults" allows for the implementation of a standard API for tokenized Vaults representing shares of a single underlying EIP-20 token. |
| ERC721                           | "ERC721" refers to a widely adopted Ethereum token standard for non-fungible tokens (NFTs). Unlike fungible tokens, each ERC721 token is unique and indivisible, making it well-suited for representing ownership of distinct digital assets. |
| ERC721Checkpointable             |                                                              |
| ERC777                           | ERC777 enhance the functionality of tokens compared to the earlier ERC20 and ERC223 standards. It introduces features like "hooks" that allow token holders to receive notifications and interact with the contract during transfers. |
| Error Reporting                  | Error reporting vulnerabilities are cases where a contract fails to properly report or handle error conditions. This category involves contracts not providing sufficient information or feedback about internal errors or issues. |
| Event                            | Event refers to a crucial feature in smart contracts that enables the emission of notifications about specific occurrences on the blockchain. |
| External Call                    | External Call refers to a mechanism in smart contracts that allows them to interact with other contracts or external accounts on the Ethereum blockchain. |
| External Contract                | External Contract refers to a separate smart contract deployed on the blockchain that can be interacted with by other contracts or external accounts. |
| Fee On Transfer                  | Fee on Transfer refers to a mechanism in token contracts where a fee is automatically deducted from the transferred amount during a transaction. |
| First Depositor Issue            | The First Depositor Issue is a potential vulnerability in smart contracts, where the first user to interact with a contract, typically to deposit funds, may exploit specific conditions or logic to gain an advantage. Alternatively, it can be front-run by a malicious actor, resulting in a loss. |
| Flashbot                         | Flashbots refers to a research and development organization that focuses on mitigating the risks associated with transaction ordering and priority in Ethereum's decentralized environment. |
| Flash Loan                       | A flash loan is a type of uncollateralized loan that lets a user borrow assets with no upfront collateral as long as the borrowed assets are paid back within the same blockchain transaction. |
| from=to                          | from=to refers to a potential exploit where a transaction sender (the 'from' address) is the same as the transaction receiver (the 'to' address). |
| Front-Running                    | Front-running vulnerabilities occur when a smart contract exposes information about future state changes, and an adversary can place transactions that exploit this knowledge for their gain. |
| Fund Lock                        | Fund Lock refers to a scenario where funds become inaccessible or locked within a smart contract due to improper handling of withdrawal or transfer functions |
| Gas Limit                        | Gas Limit refers to the maximum amount of computational work a transaction is allowed to perform on the network. Setting an incorrect or insufficient gas limit can lead to transaction failures or vulnerabilities, as it may prevent complex operations from being executed. |
| Gas Price                        | Gas Price refers to the amount of cryptocurrency a user is willing to pay per unit of computational work when submitting a transaction on the Ethereum network. |
| Grief Attack                     | A gas griefing attack happens when a user sends the amount of gas required to execute the target smart contract, but not its sub calls. In most cases, this results in uncontrolled behavior that could have a dangerous impact on the business logic. |
| Hardcoded Address                | Hardcoded Address refers to the practice of embedding specific addresses directly into the source code of a smart contract. This can introduce a security risk if the address is meant to be dynamic or changeable. |
| Hardcoded Setting                | Hardcoded Setting refers to the practice of embedding fixed values or parameters directly into the source code of a smart contract. This can pose a security risk if the setting needs to be dynamic or adaptable. |
| Hash Collision                   | Hash Collision occurs when two different inputs produce the same cryptographic hash output, notably during ABI Encoding. |
| Immediate Hash                   | Immediate Hash refers to a situation where a malicious actor can submit a payload that is a direct or immediate result of a hash operation, rather than one of the expected token IDs. This manipulation leads to unintended losses for the offerer, as they receive a token ID that doesn't match their specified criteria. |
| Immutable                        | Immutable refers to a characteristic of smart contracts that signifies that once deployed on the blockchain, their code and state cannot be altered. |
| Inheritance                      | Inheritance refers to the mechanism by which a smart contract can inherit properties and functions from another contract. |
| Initial Deposit                  | Initial Deposit refers to the first instance where a user places assets into a smart contract, often as part of a deposit or investment process. |
| Initialization                   | Initialization pertains to the process of setting up and initializing variables or states within a smart contract when it is deployed on the blockchain. |
| Initializer                      | Initializer is a special function used to set up the initial state and configuration of an upgradeable smart contract when it is first deployed. This function is essential for ensuring that the contract's upgradeable features are properly initialized, and it often includes tasks like setting initial parameters and permissions for the contract's functions. |
| initializer modifier             | initializer modifier is a special kind of function modifier used to restrict certain functions so that they can only be called during the initialization phase of a smart contract. |
| L2 Sequencer                     | L2 Sequencer refers to a component or actor responsible for orchestrating and sequencing transactions on Layer 2 solutions of the Ethereum network. It plays a crucial role in ensuring the correct order and execution of transactions. |
| LayerZero                        | LayerZero is a cross-chain communication protocol that enables direct, trustless communication between blockchains. |
| Lending Pool                     | Lending Pool is a smart contract designed to facilitate the lending and borrowing of assets within decentralized finance (DeFi) platforms. |
| Liquidation                      | Liquidation refers to the process of selling collateral assets held in a smart contract to repay outstanding debts or loans. |
| Liquidity Provider Racing        | Liquidity Provider Racing refers to a situation where multiple liquidity providers compete to be the first to provide liquidity to a pool in a decentralized finance (DeFi) platform. |
| Mapping                          | Mapping refers to a data structure that associates a value (or set of values) with a unique key. |
| Memory Pointer                   | Memory Pointer refers to a reference used to access data stored in a contract's memory. This highlights a high-risk issue where assigning a bytes memory variable to a new variable resulted in both variables pointing to the same memory location, leading to unintended changes in one variable affecting the other. |
| Merkle Tree                      | Merkle Tree is a cryptographic data structure used to efficiently prove the membership of an element within a set. |
| Migration Loss                   | Migration Loss refers to potential risks and losses that can occur during the process of migrating from one smart contract version to another. |
| Min/Max Cap Validation           | Min/Max Cap Validation refers to the practice of setting an lower or upper limit on certain parameters within a smart contract to ensure they do not exceed a specified threshold |
| MinOut/MaxIn Validation          | MinOut/MaxIn Validation pertains to the practice of enforcing specific conditions on the outputs or inputs of a smart contract function, ensuring they meet predefined minimum or maximum thresholds. |
| mint vs safeMint                 | "mint" and "safeMint" refer to functions commonly used in token contracts for creating new tokens. While "mint" typically adds new tokens directly to an address, "safeMint" incorporates additional checks if the receiver is a smart contract and implements the ERC721Receivable interface. |
| Missing Check                    | Missing Check refers to a critical oversight in a smart contract's code where a necessary condition or validation is not properly implemented. |
| Missing-Logic                    | Missing-logic vulnerabilities refer to cases where a smart contract does not have the necessary code in place to handle certain inputs or conditions properly. Essentially, it's like a gap in the program’s logic where a specific branch of code should have been implemented to address a particular scenario. While missing logic might not always be critical, it can sometimes lead to unintended consequences. |
| msgSender                        | msgSender is a term used to represent the address that triggered the current function call in a smart contract. |
| Needless receive()               | Needless receive() refers to the implementation of a receive() function in a smart contract when it is unnecessary for the contract's intended functionality. |
| NFT                              | NFT stands for ‘non-fungible token’. Non-fungible means that something is unique and can’t be replaced. |
| Nonce                            | Nonce is a value associated with an Ethereum address that ensures the uniqueness of transactions originating from that address. |
| Numerics                         | Numerics vulnerabilities involve issues related to arithmetic operations in smart contracts, such as overflows, underflows, or precision losses. This category also includes issues where the use of “safe math” libraries prevents an arithmetic error but results in unexpected reverts. |
| onlyInitializing modifier        | onlyInitializing modifier refers to a custom modifier in a smart contract designed to restrict certain functions to be callable only during the initialization phase of the contract. |
| Optimism                         | Optimism is an Ethereum layer-2 scaling solution that uses Optimistic Rollups to process many transactions off-chain while retaining the L1 security guarantees of Ethereum. |
| Optimizer Memory Side Effect     | Optimizer Memory Side Effect refers to a specific issue that arises when using the Solidity optimizer. It occurs when certain operations on memory are not explicitly cleared. |
| Oracle                           | Oracle refers to an external service or smart contract that provides real-world data to a blockchain. |
| Overflow/Underflow               | "Overflow" and "Underflow" are arithmetic errors that occur when a numerical value exceeds its maximum representable size (overflow) or falls below its minimum representable size (underflow). |
| Ownable                          | Ownable typically refers to a smart contract design pattern where a specific address, known as the owner, has special privileges and control over the contract. |
| Ownership                        | Ownership refers to the concept of identifying a specific address, known as the owner, with special privileges and control over a smart contract. |
| OZ Version                       | OZ Version refers to the version of the OpenZeppelin library, and users should always ensure they are using the latest, most secure version to mitigate potential vulnerabilities associated with outdated versions. |
| Parameter Setter                 | Parameter Setter refers to a function in a smart contract that allows users to modify certain parameters or configurations within the contract's operation. |
| Patching                         | Patching vulnerabilities pertain to issues in the mechanisms used to upgrade or modify smart contract behavior. Since smart contracts are immutable once deployed, they often use complex methods to allow updates. Vulnerabilities in this area can be due to flaws in these update mechanisms. |
| Pause                            | Pause refers to a mechanism in a smart contract that allows certain operations or functions to be temporarily halted. |
| Payable                          | Payable is a modifier in a smart contract that allows the contract to receive and handle incoming Ether (cryptocurrency). |
| Pegged                           | Pegged typically refers to a token or asset that is designed to have a stable value, often mirroring the value of another asset like a fiat currency. |
| Precision Loss                   | Precision Loss refers to the potential loss of decimal precision when performing arithmetic operations involving fractional values, particularly in the context of financial calculations. |
| Pre/Post Balance                 | Pre/Post Balance refers to the comparison of an address's token balance before and after a transaction or operation. |
| Protocol Reserve                 | Protocol Reserve typically refers to a pool or reserve of assets maintained by a protocol to cover potential losses or ensure liquidity. |
| Quorum                           | Quorum refers to the minimum number of votes or approvals required for a specific action or decision to be valid within a decentralized governance system. |
| Race Condition                   | Race condition vulnerabilities occur when the behavior of a smart contract is inadvertently dependent on the order of transactions. These vulnerabilities can result in unexpected and often harmful outcomes, especially when the contract does not properly manage the sequence of operations or events. |
| Read-only Reentrancy             | The read-only reentrancy is a reentrancy scenario where a view function is reentered, which in most cases is unguarded as it does not modify the contract's state. However, if the state is inconsistent, wrong values could be reported. |
| Rebasing Tokens                  | Rebase tokens are a type of cryptocurrency that adjusts their supply to maintain price stability. This is in contrast to traditional cryptocurrencies, which have a fixed supply determined at the time of their creation. |
| Reentrancy                       | Reentrancy vulnerabilities happen when external contract calls are made before internal state updates, allowing an adversary to recursively call back into the contract, exploiting the inconsistent state. |
| Refund Ether                     | Refund Ether typically refers to a function in a smart contract that allows users to refund their Ether holdings from the contract. |
| Replay Attack                    | A replay attack is an exploit that can occur when two forked crypto-currencies allow transactions to be valid across both chains. |
| Revert By Sending Dust           | Revert By Sending Dust refers to a technique where an attacker tries to invoke a function in a smart contract, deliberately sending a negligible amount of Ether (dust) along with the transaction. |
| Revert Inside Hook               | Revert Inside Hook refers to a situation where a smart contract's hook function, which is designed to execute custom logic during certain operations, intentionally triggers a revert operation. |
| Revert On 0 Transfer             | Revert On 0 Transfer is a vulnerability that occurs when a contract mistakenly assumes that a token transfer operation will always succeed, even when transferring zero tokens. |
| Rounding                         | Rounding refers to the process of approximating a numerical value to a specific precision or number of decimal places. |
| Royalty                          | Royalty typically refers to a fee or percentage of revenue paid to the original creator or owner of a digital asset, such as an NFT, each time it is resold. |
| SafeApprove                      | Due to the vulnerability of the approve() method in ERC20 contracts to front-running attacks, the safeApprove() method guarantees that if the current allowance is non-zero, it must be reset to zero before granting a new allowance. This precautionary check helps safeguard the contract from unintended behaviors. |
| SafeTransfer                     | SafeTransfer is part of SafeERC20, a helper designed to secure interactions with someone else's ERC20 tokens. |
| safeTransfer - code size check   | safeTransfer with a code size check is a security mechanism that verifies the recipient contract's code size before executing a token transfer, preventing funds from being sent to non-existent contracts. |
| Same Block Issue                 | Same Block Issue pertains to a situation where updates to a variable occur multiple times within the same block. However, due to an oversight in the code, only the first updated value is retained in persistent storage, potentially leading to incorrect or incomplete recording of state variables. |
| Sandwich Attack                  | Sandwich Attack is a type of front-running attack where a malicious actor exploits a transaction by inserting their own transaction both before and after the victim it in the blockchain. |
| Selfdestruct                     | Selfdestruct refers to a function in a smart contract that allows the contract owner to intentionally destroy the contract and release its remaining funds to a designated address. |
| send vs call                     | Similar to transfer, Use 'call' instead of 'send' due to gas cost considerations, and make sure to implement the CEI pattern to prevent reentrancy vulnerabilities when utilizing 'call'. |
| Sense                            | Sense is decentralized permissionless infrastructure, where teams can build and develop new yield primitives for DeFi. |
| Share Inflation                  | Share Inflation refers to a potential exploit where a malicious actor manipulates the supply or distribution of tokens in a decentralized application (DApp) to gain an unfair advantage. |
| Signature Malleability           | Signature Malleability refers to a weakness where the digital signature of a transaction can be altered without invalidating it. |
| Signed/Unsigned                  | Signed/Unsigned refers to the differentiation between signed and unsigned integers. Unsigned integers do not allow negative values, while signed integers can represent both positive and negative values. |
| Slippage                         | Slippage is the difference between the average purchase or sale price for a trade and the initial selling or market price. Slippage refers to the changes in the presiding price of an asset in the course of the execution of a trade request. |
| SOLC Version                     | SOLC Version refers to the specific compiler version of Solidity used to compile a smart contract. Using an outdated or unpatched version of the Solidity compiler can expose a smart contract to known vulnerabilities or bugs that have been addressed in newer releases. |
| Solidity 0.8.13/14               | Solidity versions 0.8.13 and 0.8.14 are vulnerable to a recently reported optimizer bug related to inline assembly. Solidity 0.8.15 has been released with a fix. |
| SOLMate                          | A Transmissions11-hosted repository of solidity smart contract writing tools and libraries for authentication, token, utility, and vault building blocks. |
| Stability                        | Stability" refers to the robustness and reliability of a smart contract or blockchain system under various conditions and potential attacks. |
| Stale Price                      | Stale Price refers to an outdated or incorrect value used for determining the exchange rate of assets in a decentralized application (DApp) or smart contract. |
| Storage Collision                | Storage Collision occurs when multiple contracts attempt to write data to the same storage slot within the blockchain. |
| Storage Gap                      | Storage Gap" is a deliberate space left unused between state variables in upgradeable contracts. It serves as a protective measure to prevent unintended consequences that may arise from the addition of new variables in parent contracts, which could potentially overwrite existing variables in child contracts during upgrades. |
| supportsInterface                | supportsInterface is a function commonly used in smart contracts to check if a contract adheres to a specific standard or interface. |
| Swap                             | Swap typically refers to the process of exchanging one token or asset for another on decentralized exchanges (DEXs) or automated market makers (AMMs). |
| Sybil Attack                     | Sybil Attack refers to a potential vulnerability where an attacker could exploit the absence of a mechanism to detect fake or malicious actor. |
| Tellor                           | Tellor is a transparent and permissionless oracle protocol for your smart contract to easily get any data whenever it needs it. |
| TimelockController Issue         | TimelockController Issue typically refers to a potential weakness in a smart contract that manages time-based operations or functions. It denotes a situation where a delay mechanism, often implemented to secure critical actions, may inadvertently allow for unforeseen or unauthorized actions to occur due to improper configuration or exploitation, potentially leading to unintended consequences or security breaches. |
| Time Rounding                    | Time Rounding pertains to the potential issue where calculations involving time may lead to imprecise results due to the discrete nature of blockchain timestamps. |
| Timing                           | Timing vulnerabilities arise when the behavior of a smart contract is dependent on certain time frames or intervals, which if manipulated, can have adverse effects. |
| Token Existence                  | Token Existence refers to a potential issue where a smart contract may not adequately verify the existence or validity of a token before performing operations with it. |
| Token Order                      | Token Order typically refers to a potential weakness in smart contracts where the sequence of token operations is not properly validated or controlled. |
| totalSupply() = 0                | totalSupply() = 0 refers to a vulnerability where an attacker manipulates the deposit process, causing the total supply of shares to remain at zero. This effectively prevents the protocol from functioning properly. |
| Transfer Result Check            | Transfer Result Check arises from the limited support for tokens that do not consistently return a boolean value upon success or failure, potentially leading to undetected transfer errors or erroneous treatment of successful transfers. |
| transferFrom vs safeTransferFrom | transferFrom vs safeTransferFrom refers to a critical distinction in how tokens are handled in case of failure. While transferFrom is utilized, it may present a vulnerability as some tokens return 'false' instead of reverting on failure, potentially enabling a malicious actor to exploit the system. The recommendation is to consistently employ the safer alternative, safeTransferFrom, to mitigate this risk and ensure secure token transfers. |
| transferFrom vs transfer         | transferFrom vs transfer denotes a crucial distinction in how tokens are moved between addresses. While transferFrom allows for a third-party to initiate the transfer, it requires approval beforehand, whereas transfer directly moves tokens from the sender's account without this additional approval step, potentially exposing vulnerabilities if not used judiciously. |
| Truncation                       | Truncation refers to the potential issue where numeric values, particularly those involving large or precise numbers, are truncated or rounded off, leading to unintended consequences or loss of precision in calculations. |
| TWAP                             | TWAP stands for Time-Weighted Average Price. This metric is used to calculate the average price of an asset over a specified time period. |
| Two-address token                | Two-address token refers to a type of blockchain-based token, exemplified by Synthetix's ProxyERC20 contract, which allows for the designation of two distinct addresses for specific token. |
| Two-Step Pattern                 | Two-Step Pattern involves a vulnerability in the ownership transfer process where the current owner directly initiates ownership transfer without adequate checks, potentially enabling unintentional transfers to invalid or uncontrolled accounts and compromising functions restricted to the owner. |
| Type casting                     | Type casting refers to the practice of converting a variable from one data type to another. Improper or unchecked type casting can lead to vulnerabilities. |
| Typo / CopyPaste                 | Typo / CopyPaste" refers to a potential issue where mistakes in code arise from typing errors or inadvertently copying and pasting code segments. |
| Undefined Behavior               | Undefined behavior vulnerabilities occur when a smart contract relies on aspects of the Solidity language or the EVM that are not clearly defined or specified. This can cause the behavior of the contract to be unpredictable or unstable. |
| Uniswap                          | Uniswap is an automated liquidity protocol powered by a constant product formula and implemented in a system of non-upgradeable smart contracts on the Ethereum blockchain. It obviates the need for trusted intermediaries, prioritizing decentralization, censorship resistance, and security. |
| Update State After Admin Action  | Update State After Admin Action pertains to a potential issue where the state of a smart contract is not appropriately updated following an administrative action. |
| Upgradable                       | Upgradable refers to a design pattern where smart contracts are structured to allow for future updates or modifications. |
| USDC                             | USDC refers to a type of stablecoin known as USD Coin.       |
| USDT                             | USDT refers to Tether, a widely used stablecoin.             |
| Validation                       | Validation refers to the process of verifying input data or conditions to ensure they meet specific criteria or requirements within a smart contract. |
| Vault                            | Vault typically refers to a secure storage mechanism within a smart contract designed to hold and manage assets. |
| veCRV                            | veCRV is a non-standard ERC20 implementation, used within the Aragon DAO to determine each account's voting power. |
| Vesting                          | Vesting pertains to a time-based release mechanism for tokens or assets held in a smart contract. |
| Veto                             | Veto typically refers to a mechanism that allows a single entity or a select group to override decisions or actions within a smart contract or blockchain system. |
| Vote                             | Vote refers to the action of expressing one's preference or decision in a decentralized governance system. |
| VRF                              | VRF stands for Verifiable Random Function. It is a cryptographic function used to generate random numbers in a way that can be independently verified. |
| Weird ERC20                      | Weird ERC20 typically refers to non-standard implementations of the ERC20 token standard. These non-standard implementations may deviate from the expected behavior of ERC20 tokens. |
| WETH                             | WETH refers to Wrapped Ether, which is a tokenized version of Ethereum's native cryptocurrency, ETH. |
| Whitelist/Blacklist Match        | Whitelist/Blacklist Match refers to a potential vulnerability where a smart contract improperly handles addresses based on predefined lists. |
| Withdraw 0                       | Withdraw 0 pertains to a potential weakness in a smart contract's withdrawal mechanism where a user might be able to initiate a withdrawal of zero tokens or funds. |
| Withdraw Pattern                 | Withdraw Pattern refers to a potential issue where a smart contract allows users to withdraw funds or tokens without adequate checks or safeguards in place. |
| Wormhole                         | Wormhole is a generic message passing protocol that enables communication between blockchains. |
| Wrong Comment                    | Wrong Comment refers to a potential issue where the comments in the smart contract's code do not accurately reflect the actual functionality or logic implemented. |
| Wrong Math                       | Wrong Math refers to a potential issue where mathematical operations within a smart contract are implemented incorrectly, leading to inaccurate calculations. |
| Wrong Time                       | Wrong Time refers to a potential vulnerability where the handling of time-related functions or conditions in a smart contract is not accurate or properly validated. This can lead to incorrect outcomes or exploitable scenarios, potentially compromising the contract's intended functionality and security. |
| ZkSync                           | ZkSync refers to a layer-2 scaling solution for Ethereum that aims to improve transaction throughput and reduce gas fees. |