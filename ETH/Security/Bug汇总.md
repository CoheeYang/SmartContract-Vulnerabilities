

[TOC]

Bug复盘：

Owen- try cathc issue

ABI-ecode stri https://solodit.cyfrin.io/issues/m-04-cidnft-broken-tokenuri-function-code4rena-canto-identity-protocol-canto-identity-protocol-contest-git

涉及外部dex，但是却没有限制传输的bytes data导致的 bypasslimit https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85

1/64 rule导致的问题 https://solodit.cyfrin.io/issues/h-08-gas-limit-check-is-inaccurate-leading-to-an-operator-being-able-to-fail-a-job-intentionally-code4rena-holograph-holograph-contest-git



1. ERC20 transfer/transferFrom不总是revert，有时候会返回0/false



## Bug list

表格：Rarity>=B时，有Heuristics

A：极少人找到的bug，此类bug会让你获得非常可观收入。

B：较少的人找到的bug，此类bug需要一定水平，并带给你一定的收入。

C：一般性的bug，比如一些写错或明显的DoS，reentrancy等经典bug。

| No.  | Description                                                  | Link                                                         | Classification                                               | Protocal Class                                | Rarity | Heuristics                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------- | ------ | ------------------------------------------------------------ |
| 1    | 持有51%投票权后通过再铸造超级投票权，以通过那些需要几乎100%投票权才能完成的proposal | [Party-Protocal](https://solodit.cyfrin.io/issues/h-01-the-51-majority-can-hijack-the-partys-precious-tokens-through-an-arbitrary-call-proposal-if-the-addpartycardsauthority-contract-is-added-as-an-authority-in-the-party-code4rena-party-protocol-party-protocol-git) | 51% attack                                                   | Governance                                    | B      |                                                              |
| 2    | ERC20作为NFT持有股权，通过建立任意proposal将其所有的ERC20转给attacker，之后attacker拿这些ERC20换整个NFT | [PartyDAO](https://solodit.cyfrin.io/issues/h-06-a-majority-attack-can-steal-precious-nft-from-the-party-by-crafting-and-chaining-two-proposals-code4rena-partydao-partydao-contest-git) | 51% attack                                                   | Governance                                    | B      |                                                              |
| 3    | lack zero address check 导致潜在的51% attack                 | [Veto]( https://solodit.cyfrin.io/issues/m-11-loss-of-veto-power-can-lead-to-51-attack-code4rena-nouns-builder-nouns-builder-contest-git) | 51% attack                                                   | Governance                                    | B      |                                                              |
| 4    |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 5    | 写错的，25%写成了4，导致错误                                 | [IQ-AI]((https://code4rena.com/reports/2025-01-iq-ai#medium-risk-findings-1)) | 写错（数值填错）                                             |                                               | C      |                                                              |
| 6    | 在流动性管理的合约中，有一个加入流动性的函数会判断对应代币对池子是否存在，如果不存在则创建一个池子，如果存在则使用这个池子。但是这个好玩的是这个池子任何人都能创建，也能定义手续费。 | [IQ-AI](https://code4rena.com/reports/2025-01-iq-ai#medium-risk-findings-2) | AcessControl                                                 |                                               |        |                                                              |
| 7    | 经典Donation Attack                                          | [IQ-AI]( https://code4rena.com/reports/2025-01-iq-ai#m-02-attacker-can-dos-liquidity-migration-in-liquiditymanagersol) | Donation Attack                                              |                                               |        |                                                              |
| 8    | 写错，检验了stateVariable，而非input                         | [IQ-AI](https://code4rena.com/reports/2025-01-iq-ai#m-03-ineffective-proposal-threshold-validation-allows-setting-arbitrary-high-values) | 写错（数值填错）                                             |                                               | C      |                                                              |
| 9    | 由于资金划分管理的不清晰导致用户可能在Operator取手续费后导致资金的减少（fuzzing推荐，对应Invariant用户存入后资金不变） | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#h-01-the-calculation-of-totalassets-could-be-wrong-if-operatorfeeamount--0-this-can-cause-potential-loss-for-the-new-depositors) | Logic Error                                                  | Staking                                       | B      |                                                              |
| 10   | 合约生态中的front running（ERC4626特有的staking导致的front-running） | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#m-01-user-can-earn-rewards-by-frontrunning-the-new-rewards-accumulation-in-ron-staking-without-actually-delegating-his-tokens) | flash-staking attack                                         | Staking                                       | A      | 有奖励发放前一瞬间的deposit，并且在之后离场，是staking合约可能存在的常见问题 |
| 11   | Modifier中的require逻辑写错                                  | [Liquid-ron](https://code4rena.com/reports/2025-01-liquid-ron#m-02-operators-are-unable-to-perform-any-actions-due-to-incorrect-modifier-implementation) |                                                              | Staking                                       | C      |                                                              |
| 12   | 合约中用户将`tgt`转入可以换`titn` ,可是存的那个函数没有先检查是否超过可存的额度，导致用户可能存了`tgt`，但是因为titn有限，之后的用户在取`titn`的时候取不出来 | [Thorwallet](https://code4rena.com/reports/2025-02-thorwallet#finding-description-and-impact) | Limited Precheck（前置check缺失）                            | Bridge                                        | C      |                                                              |
| 13   | Bridge中独有的bug，当token本身存在（部分）限制转账时（A转B在设计限制了A转账路径），attacker可以通过跨链从X转到另外一个链Y，再通过Y转X中的B账户实现绕开限制（[如LayerZero::OFT中的send方法](https://github.com/LayerZero-Labs/LayerZero-v2/blob/main/packages/layerzero-v2/evm/oapp/contracts/oft/OFTCore.sol)） | [Thorwallet](https://code4rena.com/reports/2025-02-thorwallet#h-2-the-user-can-send-tokens-to-any-address-by-using-two-bridge-transfers-even-when-transfers-are-restricted) | 跨链转账                                                     | Bridge                                        | A      |                                                              |
| 14   | 通过改变其他用户的flag，导致用户无法成功进行转账             | [ThorWallet](https://code4rena.com/reports/2025-02-thorwallet#m-1-improper-transfer-restrictions-on-non-bridged-tokens-due-to-boolean-bridged-token-tracking-allowing-a-dos-attack-vector) | DoS (改变其他人的数据导致)                                   | Bridge                                        | C      |                                                              |
| 15   | 锁定流动性池`lock_pool`需要一个创建一个`lock_escrow account`，但是没用check这个account是否已经存在，如果已经存在则会出现DoS | [Pump-science](https://code4rena.com/reports/2025-01-pump-science#h-01-the-lock_pool-operation-can-be-dos) | DoS(提前占据他人数据)                                        | Bonding Curve                                 |        |                                                              |
| 16   | 函数未成功更新结构体数据                                     | [Pump-science](https://code4rena.com/reports/2025-01-pump-science#h-02-missing-update-of-migration_token_allocation-on-global-struct) |                                                              |                                               |        |                                                              |
| 17   | 。。。Pump Science（由于是rust的，这里先空着，之后学rust再补齐） |                                                              |                                                              |                                               |        |                                                              |
| 18   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 19   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 20   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 21   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 22   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 23   | 在Flow control中，deposit的flow没有被成功finalize，导致DoS（对于多数flow control都有参考意义） | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-02-deposits-on-long-one-leverage-vault-dont-actually-finalize-the-flow-leading-to-a-denial-of-service-dos) | DoS(缺乏完整逻辑)                                            | Strategy                                      | B      |                                                              |
| 24   | PNL损益的计算错误（藏的非常深）                              | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-02-deposits-on-long-one-leverage-vault-dont-actually-finalize-the-flow-leading-to-a-denial-of-service-dos) | Logic error                                                  | Strategy                                      | B      |                                                              |
| 25   | Mint所计算的shares出现问题，会导致同样的deposit，后续deposit的人反而会有更多shares。根本原因在于在计算“仓位净值”（`netValue`）时，错误地将**positionFee**（挂单手续费）也一并从净值中扣除，导致后续根据`netValue`与已有份额计算新用户应得份额时低估了整个池子的总资产值（`totalAmountBefore`），反过来使得后续每次存入者获得的份额越来越多，从而让“晚入场”的用户占到不公平的份额增益。           （推荐寻找方法：从结果出发，看是否会出现不公平的问题） | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#h-05-subtracting-position-fee-in-position-net-value-will-lead-to-incorrect-share-allocation) | Logic error                                                  | Strategy                                      | A      |                                                              |
| 26   | 根据官方文档中，存在多个`orderHandler` 的角色，但是它只写了一个地址。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-02-perpetualvault-can-be-completely-bricked) | Logic error                                                  | Strategy                                      | C      |                                                              |
| 27   | 为检查创建订单等行为时用户账户所花费的gas是否大于账户余额，`getExecutionGasLimit`会估算总gas量，但是其中计算出现了缺乏估计`swapPath`长度，导致多跳swap（如Link->USDC->Weth）的gas估计失真。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-03-getexecutiongaslimit-reports-a-lower-gas-limit-due-to-gasperswap-miscalculation) | Logic error                                                  | Strategy                                      | C      |                                                              |
| 28   | `_validatePrice`中存在检查L2 Sequencer是否正常运行的逻辑，Sequencer是L2链中常见的交易排序和打包到L1的关键组件，Chainlink PriceFeed可以监测其是否正常运行。但是项目部署的一个链Avalaunch并非L2，而是L1，且`sequencerUptimeFeed`中的对应地址是硬编码的，导致潜在的DoS。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-04-functions-that-rely-on-chainlink-prices-cannot-be-queried-on-avalanche-due-to-sequencer-uptime-check) | PriceFeed                                                    | Strategy                                      | B      | 不同链相关的问题，特别是L2 sequencer这一概念的理解           |
| 29   | 对于被清算的仓位，合约中没有对shares进行清算的逻辑，导致后续开仓的人shares不正确 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-05-incorrect-share-accounting-after-liquidation-leading-to-ownership-dilution) | Logic error                                                  | Strategy                                      | B      |                                                              |
| 30   | `GmxProxy.sol`中的GMX's ADL 行为将Gmx的钱转入`PerpetualVault`，但是`PerpetualVault`的withdraw行为依赖`balanceOf(this)`，如果在withdraw前触发ADL，用户可以获得更多。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-06-user-may-withdraw-more-than-expected-if-adl-event-happens) | Logic error                                                  | Strategy                                      | B      | 当看见`balanceOf(this)`时检查外部操作此数据的方法            |
| 31   | GMX中的ADL和liquidation行为最后的output token可以是ETH，而非WETH，`GmxProxy.sol`也存在receive函数，如果output是ETH，那么最后会转入`GmxProxy.sol`，但是`GmxProxy.sol`缺乏对应的转出ETH的函数，导致ETH被卡在合约中出不去。 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-07-adl-can-result-in-unwrapped-eth-as-output-which-is-not-handled) | Logic error                                                  | Strategy                                      | A      | 1. 外部依赖交易所的具体情况值得注意 <br />         2. 类似的output token是ETH,而非ERC20 token的情况值得考虑 |
| 32   | 这也是一个GMX原生设计上的点，GMX对于`MarketProps`中的`indexToken `指数代币，并非全是ERC20标准的合约，比如对BTC/USD，它设计的indexToken的合约地址是一个chainlink Aggregator 合约地址，此时任何关于`indexToken`的如balanceOf的调用都是错误的 | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-08-fetching-indextokenbalanceof-will-always-revert-for-btc-market) | Logic error                                                  | Strategy                                      | A      | 关注外部交易所对于BTC,ETH等代币的合约是否采用ERC20标准       |
| 33   | `totalDepositAmount`在liquidation和withdraw行为中都没有更新，导致`totalDepositAmount`在deposit中一直上涨触发`maxCapReached` | [Gamma-LiquidityManagement](https://github.com/CoheeYang/2025-02-gamma/blob/main/Liquidity-Management.md#m-09-new-deposits-be-incorrectly-rejected-due-to-false-maxcapreached-errors) | Logic error                                                  | Strategy                                      | A      | 跟踪并检查state variable是否正确的更新，是否有办法扭曲它     |
| 34   | 错误的指数exp处理，在exp为偶数除以2后又加上了1               | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-01-early-72-digit-adjustment-in-sqrt-will-lead-to-incorrect-result-exponent-calculation) | Logic error                                                  | MathLib                                       | B      |                                                              |
| 35   | 0的sqr会revert，这很错误                                     | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-02-sqrt-function-silently-reverts-the-entire-control-flow-when-a-packed-float-of-0-value-is-passed) | Logic error                                                  | MathLib                                       | C      |                                                              |
| 36   | Ln接受0值和负值输入                                          | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-03-natural-logarithm-function-silently-accepts-invalid-non-positive-inputs) | Logic error                                                  | MathLib                                       | C      |                                                              |
| 37   | `function eq(packedFloat a, packedFloat b) internal pure returns (bool retVal) {         retVal = packedFloat.unwrap(a) == packedFloat.unwrap(b);     }`<br />出现错误，它将一个自己设计的type `packedFloat`unwarp回`uint256`来进行比较，但是这种比较会出现同一个数字，72位表达和38位表达最后比较的结果会不相等。 | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-04-unwrapping-while-equating-inside-the-eq-function-fails-to-account-for-the-set-l_matissa_flag) | Logic error                                                  | MathLib                                       | B      | 同一数据，由于表达格式flag不同导致`eq`失效                   |
| 38   | 最基本的转化函数`toPackedFloat`在M和L中间的判断的数中，有一个明显的截断除法，导致数据很多的数直接转为M尾数，造成精度的丢失 | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#h-05-precision-loss-in-topackedfloat-function-when-mantissa-is-in-range-max_m_digit_number-min_l_digit_number) | Logic error                                                  | MathLib                                       | B      | 格式转化中的截断div，是否会导致过量的数据丢丢失              |
| 39   | auto scaling rule的方法在`toPackedFloat`和其他地方都不一致   | [Float128](https://code4rena.com/reports/2025-04-forte-float128-solidity-library#m-01-inconsistent-mantissa-size-auto-scaling-between-packedfloat-encoding-and-calculations-will-lead-to-unacceptable-rounding-errors) | Logic error                                                  | MathLib                                       | A      | 非常有争议，但是确实也提供了一个好的角度；是否全局上存在不一致的rule |
| 40   | 这个案例非常好的阐释了什么叫没有用的保护。函数在交易的内部进行计算的slippage protection是多少，而且还依赖于`uni.getAmountOut`，攻击者可以和往常一样进行三明治攻击，此时函数内得到的minAmount已经被操控，这个protection一点用都没有。 | [Pashov Audit Group](https://solodit.cyfrin.io/issues/h-01-_swap-is-vulnerable-to-sandwich-attacks-pashov-audit-group-none-gacha_2025-01-27-markdown) | Sandwich Attack                                              |                                               | A      | 任何涉及swap的buy/sell都需要有主入口函数的slippage protection，`minAmount`，内部计算动态计算是没用的。 |
| 41   | 和之前gamma依赖交易所claim的ETH无法转出的bug类似，此bug由于ERC4626的escrow只定义了一种asset token，如果从外部的`Morpho`借贷平台获取其他token时会卡住出不来。 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/527) | Logic error                                                  | StableSwap （无滑点的eBTC与btc计价资产的swap) | A      | 非常有意思，和之前gamma的ETH无法转出类似，这里是其他token无法转出。所以检查外部平台所发给合约的奖励也是非常重要的 |
| 42   | eBTC作为和其他BTC资产交互的平台，在`EbtcBSM::sellAsset()`中，并没有考虑到decimal的不一致的情况，像 [cbBTC](https://etherscan.io/address/0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf#readProxyContract#F11), [LBTC](https://etherscan.io/address/0x8236a87084f8b84306f72007f36f2618a5634494#readProxyContract#F7) and [ether.fi BTC](https://etherscan.io/address/0x657e8c867d8b37dcc18fa4caead9c45eb088c642#readContract#F5) 都是8位，而eBTC是18位 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/505) | ERC20                                                        | StableSwap                                    | B      | 交换外部erc20的decimal是否存在对齐的问题。有没有`*token.decimal()` |
| 43   | chainlink合约中本应该返回`tBTC/BTC`的answer数值，但是最后计算中`_convertAnswer()`中写的计算方法是`BTC/tBTC` | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/275) | PriceFeed                                                    | StableSwap                                    | C      | priceFeed data的处理写反了，这是很low的bug，但是也是可能在priceFeed中出现的。 |
| 44   | 合约试图获得`BTC/USD` and `tBTC/USD`的价格，并转转化为`BTC/tBTC`的价格，但是两个价格的heartbeat差距太大，一个`86400s`，一个`3600s`，这导致最后乘法永远拿老数据和新数据乘。<br />同时它也将两个`updatedAt`选最小来进行比较，这也导致check staleness会出现问题。 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/259) | PriceFeed                                                    | StableSwap                                    | B      | 涉及priceFeed中的类似的staleness check和转化问题，切记priceFeed的heartbeat差距的问题。 |
| 45   | 在migration到另外一个escrow的操作中，由于对外部redeem操作可能revert导致invariant的失败，即migration fail。这些失败的情况包括：<br />1.外部vault pause或者frozen <br />2.没有shares  to redeem<br />3.redeem的share超过maxRedeem的限制 | [eBTC](https://cantina.xyz/code/f57ffb47-0ded-4f04-bcec-ecd7d47fad58/findings/131) | Logic error                                                  | StableSwap                                    | B      | 1. Invariant的打破<br/>2. 仔细检查external call revert的情况 |
| 46   | 新的Fork中引入了8位的BTC相关的抵押物，原Liquidity v2的抵押物都是18位的 | [BitVault](https://code4rena.com/reports/2025-04-bitvault#m-01-the-current-implementation-is-incompatible-with-wbtc-as-collateral-token) | ERC20                                                        | Lending                                       | B      | 其实这个bug并不难找，只是项目根本没人做，因为项目只有15000预算，且代码3000+<br />可是又由于是fork代码，这个价格也合理 |
| 47   | 可以被bypass的whitelist逻辑，NFT的mint对象必须是whitelist的，但是NFT是可交易的，这种whitelist一点用都没用 | [BitVault](https://code4rena.com/reports/2025-04-bitvault#m-02-non-whitelisted-owner-can-also-holdown-a-trovenft) | Access Control                                               | Lending                                       | A      | bypass whitelist                                             |
| 48   | 一个关于ERC4626的问题，ERC4626`deposit/withdraw`最后return shares，而非amount，而开发者一直一位是amount来进行deploy等操作的计算 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-01-users-may-encounter-losses-on-assets-deposited-through-strategysupplyerc4626) | Logic error                                                  | Strategy                                      | B      | ERC4626的deposit/withdraw输出的是shares<br />(刨根问底，一个external call即使最后是接口也要弄清最后的逻辑) |
| 49   | `harvest()`作为一个修改state variable的函数，会更新账户总资产并return`balanceChange`，但他是public函数，且收手续费的`_harvestAndMintFees`也会需要它来判断`balanceChange>0 ? 收手续费:不收`，这就导致任何人都能调用`harvest`更新数据逃避手续费。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-02-anyone-can-call-strategysupplybaseharvest-allowing-users-to-avoid-paying-performance-fees-on-interest) | Access Control                                               | Strategy                                      | B      | public函数很可怕，能更新state variable的public函数更可怕     |
| 50   | `StrategySupplyBase.undeploy`没有更新state variable`_deployedAmount`，逻辑缺失 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-03-_deployedamount-not-updated-on-strategysupplybaseundeploy-preventing-performance-fees-from-being-collected) | Logic error                                                  | Strategy                                      | C      |                                                              |
| 51   | 合约中使用的ERC4626用的18位decimal，但是这个用于可能接收外部token的strategy合约，并没有在其存入函数deploy中管理不同的decimal。（vault和strategy的decimal不对齐） | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-04-there-are-multiple-issues-with-the-decimal-conversions-between-the-vault-and-the-strategy) | ERC20                                                        | Strategy                                      | B      | checklist加上，外部资产mint shares之前或者burn之前，是否对齐decimal |
| 52   | `ERC20Permit`函数中的signature replay，没有验证msg.sender的身份，链上可以有人在发送者交易后，截取v,s,r抢跑将用户的钱转入Router合约，后通过`dispatch`中的sweepToken转入自己的口袋 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-05-the-implementation-of-pulltokenswithpermit-poses-a-risk-allowing-malicious-actors-to-steal-tokens) | signature replay                                             | Strategy                                      | A      | 涉及签名的vrs一定要有额外验证，没有额外验证就是一个风险点    |
| 53   | 和上面有点类似，但是是由于 [`VaultRouter#execute()`](https://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiCommand.sol#L72-L87) 执行命令可以将用户approven的用户通过`PULL_TOKEN_FROM`转入Router，但是转出函数`PUSH_TOKEN_FROM`对象又没有管制，导致任意人可以先`PULL_TOKEN_FROM`将其他人的token转入合约，再`PUSH_TOKEN_FROM`转到自己口袋 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-06-malicious-actors-can-exploit-user-approved-allowances-on-vaultrouter-to-drain-their-erc20-tokens) | Access Control                                               | Strategy                                      | B      | 没有加以管制的转入函数`PULL_TOKEN_FROM`和转出函数`PUSH_TOKEN_FROM` |
| 54   | 类似上面，不过这里是执行reedeem shares后再执行`PUSH_TOKEN_FROM`盗取用户的shares | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#h-07-malicious-actors-can-exploit-user-approved-allowances-on-vaultrouter-to-drain-their-erc4626-tokens) | Access Control                                               | Strategy                                      | A      |                                                              |
| 55   | 不符合ERC4626的规范，导致的问题如：`maxDeposit`总是返回`type(uint256).max`，但是deposit相关的函数要检查这个limit，导致一个空洞且无用的检查，并且在pause状态下`maxDeposit`并不返回0 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-01-vaultbase-is-not-erc4626-compliant) | ERC4626                                                      | Strategy                                      | A      | 比较珍奇的bug，。规范问题值得列入checklist中                 |
| 56   | 管理多个strategy的逻辑中，当通过`addStrategy`来新加入一个`strategy`时，没有任何的给予新策略allowance的方法，导致新策略一直没钱进行获得 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-02-new-strategy-can-not-work-due-to-insufficient-allowance) | DoS                                                          | Strategy                                      | B      |                                                              |
| 57   | 在 `MultiStrategy.sol` 的 `removeStrategy` 函数中，移除一个有已部署（deployed）资产的杠杆策略时，合约按照 `strategyAssets = totalAssets()` 计算待撤出的资产量，再调用 `undeploy(strategyAssets)` 执行撤出，最后却仍以原始的 `strategyAssets` 数值重新分配给剩余策略（`_allocateAssets(strategyAssets)`）。对于杠杆策略而言，`undeploy` 中会通过 ERC-3156 标准的闪电贷（flash loan）借入债务、偿还并取出抵押、支付利息等操作，实际返还的资产往往 **少于** 请求撤出的数量[Code4rena](https://code4rena.com/reports/2024-12-bakerfi-invitational?utm_source=chatgpt.com)。这种不一致导致后续 `_allocateAssets` 尝试分配超过实际可用的资产量，从而使得“移除”操作在资金不足时失败，策略无法被删除，长期锁定了该条策略。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-03-multistrategyremovestrategy-cannot-remove-leverage-strategies-that-still-have-deployed-assets) | Logic error                                                  | Strategy                                      | B      |                                                              |
| 58   | 在 **VaultBase** 合约的 `_depositInternal` 方法中，只允许当 `totalAssets()` 与 `totalSupply()` 同时为零或同时为正时才可继续存款。然而，攻击者可在任意时机（包括首次存款之前或所有份额被提走后），**直接向底层 Strategy 合约转入代币**，使得 `totalAssets()` > 0 且 `totalSupply()` = 0，从而触发不匹配的状态检查，导致后续任何用户存款全都被 `InvalidAssetsState` 拦截，导致DoS | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-04-sending-tokens-to-a-strategy-when-totalsupply-is-0-can-permanently-make-the-vault-unavailable) | Donation Attack                                              | Strategy                                      | C      |                                                              |
| 59   | DAI 使用 `permit` 时有兼容性问题，<br />正常的`IERC20Permit(token).permit(  address owner,  address spender,  uint256 value, uint256 deadline,  uint8 v, bytes32 r, bytes32 s);`<br/>而DAI中：<br />`permit(address holder,  address spender,  uint256 nonce,  uint256 expiry,  bool allowed,  uint8 v,  bytes32 r,  bytes32 s)` | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-05-permit-doesnt-work-with-dai) | ERC20                                                        | Strategy                                      | A      | 特殊ERC20 Permit案例                                         |
| 60   | modifier缺失，根据docs， `rebalance`本应该在pause的时候也暂停，但是实际上没有 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-06-even-when-the-vault-contract-is-paused-the-rebalance-function-is-not-paused) | Logic error                                                  | Strategy                                      | B      | 读文档，注意比如pause这个modifer的管辖范围                   |
| 61   | VaultBase 在内部存款逻辑 `_depositInternal` 中，对单个 `msg.sender` 的累计存款额设有 `_maxDeposit` 限制，但在检查时却错误地使用了 `balanceOf(msg.sender)` 而非接收者（`receiver`），攻击者可通过指定不同的接收地址多次存款而不增加自身余额，从而**无限绕过**最大存款上限。<br />正确的方法是使用mapping来检查而非`balanceOf(msg.sender)` | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-07-depositor-can-bypass-the-max-deposit-limit) | Logic error                                                  | Strategy                                      | B      | 检查没对齐导致的bypass                                       |
| 62   | 写错，导致action无法正常运行                                 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-08-the-dispatch-function-of-the-vaultrouter-does-not-work-as-intended-with-pull_token-action) | 写错                                                         | Strategy                                      | C      |                                                              |
| 63   | `VaultBase` deposit/mint/withdraw/redeem的函数都是`onlyWhiteListed`修饰的函数，防止未知地址收到得到shares与token，但是deposit中的receiver却没有做whitelist检查，这就bypass了whitelist check，这些非白名单用户通过`VaultRouter`就能进行shares的提现 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-09-non-whitelisted-recipient-can-receive-shares) | Logic error                                                  | Strategy                                      | B      | 一个非常隐蔽的bypass whitelist check，一旦有whitelist我们需要check，有没有类似的方法去绕过它 |
| 64   | 算是经典for循环中由于一个revert导致整个逻辑阻塞的案例，在这里只要有一个strategy的totalAsset为0，即`currentAssets[i]`=0，就会导致DoS | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-10-the-withdrawal-of-multi-strategies-vault-could-be-dosed-while-asset-deposits-remain-unaffected) | DoS                                                          | Strategy                                      | A      | for循环中出现revert的导致整个DoS的经典案例，对于for循环得DoS的注意 |
| 65   | 有点像我在[aegis-op-grant-CoheeYang](https://github.com/sherlock-audit/2025-04-aegis-op-grant-CoheeYang)中的发现，也是在一个`if(x>=y)`的比较中低估/高估了被比较数，这里则是在 `StrategySupplyMorpho.sol` 中，`_undeploy` 函数为确定“最大可撤出资产”（`assetsMax`）直接使用了合约存储的 `totalSupplyAssets` 与 `totalSupplyShares`，却忽略了自上次更新以来在 Morpho 协议中已累计的利息和费用，因此 `assetsMax` 被系统性**低估**。当用户请求提现量 `amount` 超过该低估的 `assetsMax` 时，合约会走到“全额赎回”分支，将策略中所有份额全部转换并返还给用户，导致他们不仅提取了自己的利息收益，还拿走了**其他用户**的本金和利息，形成对剩余份额持有者的严重损失风险 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-11-the-calculation-of-assetsmax-is-incorrect) | Logic error                                                  | Strategy                                      | A      | 有点像我在[aegis-op-grant-CoheeYang](https://github.com/sherlock-audit/2025-04-aegis-op-grant-CoheeYang)中的发现，也是在一个`if(x>=y)`的比较中低估/高估了被比较数 |
| 66   | 和之前for循环中一个revert全部revert一样，这里是由于for循环中一个外部三方pause导致call无法进行withdraw，从而导致全部for循环中的都revert掉。<br />这里给了我们新的revert的洞察，值得一看 | [BakerFi]()                                                  | DoS                                                          | Strategy                                      | A      | For循环中，没有continue的都得注意，外部三方的revert也可能成为严重的DoS。 |
| 67   | `MultiStrategyVault`仅剩最后一个strategy时，`removeStrategy` 函数在更新完 `_totalWeight` 并清空该策略权重后，还未将策略从数组中移除，就会调用 `_allocateAssets` 对所有（此时仅剩的）策略按新权重重新部署资产。由于此时 `_totalWeight == 0`，在计算 `(amount * _weights[i]) / _totalWeight` 时会触发“除以零”错误（panic: division or modulo by zero），导致最后一个策略**永远无法被移除**。 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-13-the-vault-manager-is-unable-to-delete-the-last-strategy-from-multistrategyvault) | Logic error                                                  | Strategy                                      | A      | 有点争议，但是极值确是是一个比较好的思路                     |
| 68   | 最奇特的bug发现，即constructor中的asset与后续的`loanTokens`不一样就会造成合约不可用。<br />我觉得很扯淡，但是这确实算进去了 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-14-the-strategysupplymorpho-allow-to-use-wrong-token-in-_asset) | Logic error                                                  | Strategy                                      | B      | 最奇特的bug发现                                              |
| 69   | 混乱的调用关系，如果使用VaultRouter进行deposit，那么maxDepositLocal的检查将会很轻易地revert，因为`_depositInternal`检查的是msg.sender的balance，即router的balance，而不是用户的 | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-15-vaultrouter-cannot-be-used-for-deposits-when-it-reaches-the-maximum-deposit-limit) | Logic error                                                  | Strategy                                      | B      |                                                              |
| 70   | 纯写错                                                       | [BakerFi](https://code4rena.com/reports/2024-12-bakerfi-invitational#m-16-strategysupplybaseundeploy-does-not-return-the-amount-of-assets-actually-undeployed-which-can-cause-a-withdrawal-to-fail) |                                                              |                                               |        |                                                              |
| 71   |                                                              | [Nibiru](https://code4rena.com/reports/2024-11-nibiru#h-01-vesting-account-preemption-attack-preventing-future-contract-deployment) |                                                              | L1 chain (Go)                                 |        |                                                              |
| 72   | 在 外部的一个关于``sparse binary Merkle Patricia Trie`项目Scroll zkTrie 的设计文档中，为避免密钥表示在有限域（Poseidon 哈希所在域）中出现二义性，需要限制树的最大深度为 248 位（即最多遍历键的低 248 位）。但在 `ScrollVerifierHooks.sol` 的一个遍历该MP树的函数 `walkTree` 实现中，主循环里并未加入任何深度上限检查 | [Unruggable](https://code4rena.com/reports/2024-12-unruggable-invitational#m-01-zktrie-maximum-depth-limit-is-not-enforced-in-scroll) | Logic error                                                  | ENS                                           | A      | 算法问题，注意看文档和了解基础算法                           |
| 73   | 在 项目中`OPFaultVerifier.sol` 的 `getStorageValues` 方法中，验证逻辑调用了 Optimism Portal（`IOptimismPortal`）提供的游戏查询接口，却**未检查该游戏是否已被 Guardian 黑名单化**。而在 Optimism Portal 的设计中，一旦游戏因“错误解析”被黑名单化，就意味着该游戏的结果不可信，任何基于此游戏的后续状态证明都应被拒绝。 | [Unruggable](https://code4rena.com/reports/2024-12-unruggable-invitational#m-01-zktrie-maximum-depth-limit-is-not-enforced-in-scroll) | Logic error                                                  |                                               | A      | 这类bug是在外部调用合约中非常常见的，比如一个staking项目中（mystic finance）对validator有active检查，却少了slashed检查。这种状态变量可能是单纯的值类型，也可能是struct类型和mapping,在这里就是少忽略了`blackListed`的mapping的检查 |
| 74   | 在 Starknet 端cairo文件的 `receive_cross_chain_msg` 实现中，并违反了项目文档中“跨链消息只能被接收一次”的核心不变量。由于缺失对已处理交易状态 `CrossChainMsgStatus.Unknow` 的检查，任何人均可重复提交已成功并有效的交易参数，进而多次执行相同的跨链消息，造成资产二次发放或协议状态混乱[Code4rena](https://code4rena.com/reports/2024-08-chakra?utm_source=chatgpt.com)。攻击者无需持有私钥或额外权限，只需重放已知参数即可获利 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-02-in-starknet-already-processed-messages-can-be-re-submitted-and-by-anyone) | Access Control                                               | Bridge (BTC cross chain)                      | C      |                                                              |
| 75   | `ChakraSettlement` 合约中的 `nonce_manager` 映射被设计为 `mapping(address ⇒ uint256)`，并在外部可调用的 `send_cross_chain_msg` 中对任意 `from_address` 进行自增，导致攻击者可“替他人”增加 nonce，从而使处理跨链交易时生成的 `txid` 与预期不符，破坏系统对交易 ID 的一致性和安全假设。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-07-anyone-can-manipulate-user-nonce-nonce_manager-in-settlement-contract) | Access Control                                               | Bridge                                        | C      |                                                              |
| 76   | bridge后settle中的函数`receive_cross_chain_msg`中未`payload`包含进消息哈希的生成与签名验证流程里。而`payload`这个输入会被emit给链下机器人执行相对应的任务，如果有人抢跑了签名，并修改对应的payload，则会导致错误的任务被执行。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-08-in-settlementcairoreceive_cross_chain_msg---the-payload_type-can-be-passed-by-the-user-confusing-offchain-systems) | Signature Replay                                             | Bridge                                        | A      | 非常复杂的bug，是链上emit的信息被它人修改后由链下机器人接收。<br />本质上过于宽松的签名处理，签名没有包括所有的要emit内容。 |
| 77   | 不同版本的`receive_cross_chain_callback`，对同样的行为做出了不同的动作，cairo会revert非白名单handler发来的交易，而solidity则返回false。前者会将处于`CrossChainMsgStatus.Pending`交易卡住，导致DoS。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-09-inconsistent-handler-validation-behavior-in-cairo-erc20handlers-cross-chain-callback) | Logic error                                                  | Bridge                                        | A      | 系统内多个脚本处理的不一致导致的问题<br />系统流程搞清楚非常重要 |
| 78   | 多个函数中的校验签名时同样**不包含**任何链ID的信息，导致如果CREATE2 或同一密钥得到不同链上的相同合约地址时，若 to_chain A 和 B 上的 Validator 集合、Handler 地址、白名单配置均相同，则 A 链签署的跨链消息同样能在 B 链被视为合法 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-10-chakrasettlementreceive_cross_chain_msg-and-chakrasettlementreceive_cross_chain_callback-functions-do-not-ensure-that-receiving-chakrasettlement-contracts-contract_chain_name-must-match-to_chain-corresponding-to-respective-txid-input-though-they-should) | Signature Replay                                             | Bridge                                        | A      | 跨链中的校验签名在不同链上的复用。                           |
| 79   | 结算系统中的handler缺乏refund机制，导致跨链交易失败后会产生资金丢失。 | [chakra](https://code4rena.com/reports/2024-08-chakra#h-11-there-is-no-refund-mechanism-in-chakrasettlementprocesscrosschaincallback-or-chakrasettlementhandlerreceive_cross_chain_callback-function) | Logic error                                                  | Bridge                                        | A      | Bridge中，从链A到B，需要将A中的token进行lock/burn/transfer，再经过系统验证后再到B链上生成对应的token。<br />但是万一中间过程失败了怎么办？失败了应该有refund机制将原A链的token还给user，但是这里却没有，而是直接返回fail的信息而已。 |
| 80   | Lock和Mint的方法用反了                                       | [chakra](https://code4rena.com/reports/2024-08-chakra#h-13-the-lockmint-and-burnunlock-modes-cannot-be-used) | Logic error                                                  | Bridge                                        | A      | 这个问题看上去很简单，但是却很少人发现。                     |
| 81   | Hans 发现的bug，非常有意思。<br />具体而言是一个swap换钱的合约中，swap中的手续费会当成LP的奖励直接distribute。问题出现于交易顺序，它是先distribute再将caller的钱转进来，一开始因为有存储所以没问题但是到了后面存储用完就会因为资金耗尽而revert | [Upside](https://github.com/code-423n4/2025-05-upside/blob/main/2025-05-16-hans-upside-v4.pdf) | Logic error                                                  | Tokenization Platform                         | A      | 交易顺序！                                                   |
| 82   | 在一般的vault中 mint/deposit 时计算要给用户铸造的份额<br/>` shares == 0? Amount: Amount* totalShares / totalAssetsInContract`<br/>Attacker可以先mint 1wei的shares，再人为转账到合约如`1000e18-1`的token，使得`totalShares/totalAssets`极度容易decimal loss。<br/> 当用户 redeem/burn 时，根据其份额计算能取出的资产<br/>`tokens = shares * totalAssetsInContract / totalShares`<br />此时其他任何的用户存入只要decimal loss，attacker就可以白嫖它们存入的钱。 | [PoolTogether](https://solodit.cyfrin.io/issues/h-01-a-malicious-early-userattacker-can-manipulate-the-vaults-pricepershare-to-take-an-unfair-share-of-future-users-deposits-code4rena-pooltogether-pooltogether-git) | PPS Manipulation                                             | Strategy                                      | B      | Inflation Attack的根源在于使用`balanceOf(this)`计算的资产数量，最佳其实应该使用一个mapping进行记录，或者在一开始就人为地存入钱 |
| 83   | Silo vault是一个聚合vault，将用户存入的钱按策略来存入到其他各种market vault中以获取利润。<br />然而在deposti到其他vault的逻辑中，一个for循环只是单纯的进行存入动作，而没有考虑market.vault的`maxDeposit`.这就导致了可能vault1和vault2剩下的总余额够`siloVault`存，但是单次存入的余额却不够而无法成功分配资金。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-01-supply-function-doesnt-account-for-market-maxdeposit-when-providing-assets-to-it) | ERC4626                                                      | Lending                                       | B      | 聚合vault存入其他多个vault前，没有检查其他vault的总余额而按情况进行分配。 |
| 84   | 在分配手续费中，Silo finance选择在每次用户操作时使用`_accrueFee()`来给`feeRecipient`铸造一些vault shares来获取底层资产利息的增值。<br />在`claimRewards()`中先调用 `_accrueFee()`以保证`feeRecipient`的shares被mint了，从而再执行`_claimRewards()`来进行合理的分配。<br />但是在`_update()`中却缺少了`_accrueFee()`而直接执行了`_claimRewards()`，这样用户可以通过`transfer/transferFrom`直接claim，而绕开手续费。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-02-silovault-will-incorrectly-accrue-rewards-during-user-transfertransferfrom-actions-due-to-unsynced-totalsupply) | Logic error                                                  | Lending                                       | B      | 手续费分配机制的缺失，导致潜在的bypass使得`feeRecipient`的利益受损 |
| 85   | Remove market要求将token的approve设置为0，然而有些如BNB币approve zero会revert，从而无法移除该vault. | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-03-silovaultsol--markets-with-assets-that-revert-on-zero-approvals-cannot-be-removed) | ERC20                                                        | Lending                                       | A      | approve设为0时会revert的bug。Wired ERC20                     |
| 86   | 聚合器vault的`deposit/redeem`是和多个市场vault进行交互，却没有slippage protection/deadline.<br />这就导致一旦底层 market 在交易执行之前或中途发生价格波动，用户就可能获得少于预期的 Vault Share。同理，在 `withdraw()` 或 `redeem()` 时，如果某个 market 流动性不足、迫使合约转移到下一个 market，那下一个 market 的兑换率可能更差，最终用户实际拿到的底层资产就会比他提交时预期的少。<br />同时没有设置`dealline`，交易可能卡在memepool中，最后交易会在一个unfavored price成交。 | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-04-lack-of-slippage-and-deadline-protection-in-deposit-withdraw-and-redeem) | Logic error                                                  | Lending                                       | B      | Slippage protection不光得需要在诸如AMM的`swap()`中有，也需要在这样的聚合器中有，防止价格走势影响用户的利益。<br />凡是价格/时间敏感的都得注意`slippage`和`deadline` |
| 87   | `claimRewards()`在计算`feeRecipient`的份额时，调用`_accrueFee()`会mint给其一定的shares，但是mint同时会触发`update()`从而触发`_claimRewards()`,使得caller回收奖励。<br />但是问题就在于执行顺序上，此时触发`_claimRewards()`并没有调用`super.update`更新`feeRecipient`的shares，使得此次的claim并不会让新mint的shares被考虑进去，从而让feeRecipient利益受损，而user获得更多rewards | [SiloFinance](https://code4rena.com/reports/2025-03-silo-finance#m-05-incorrect-reward-distribution-due-to-feeshares-minting-order) | Logic error                                                  | Lending                                       | S      | 更新顺序得注意                                               |
| 88   | 类似inflation attack，由于存入资产mint的share由`_assets.mulDiv(_newTotalSupply + 10 ** _decimalsOffset(), _newTotalAssets + 1, _rounding)`计算而来，存入1wei，会使得mint `1*10e18/1`（假设offset=18），但是实际资产没有增加，因为1wei存到其他market中会直接由于decimal loss掉。反复如此shares狂增而asset没有增加。<br /> | [SiloFinance]()                                              | PPS Manipulation                                             | Lending                                       | S      | 其实主要是这个bug是因为没有资产被增加，shares却增加了invariant被打破了。即使如此我们要得思考类似的产生大数的情况，比如存入1e18可能就会mint 1e36的情况。会不会超过uint256最大值。 |
| 89   | YUSD 是一个以“抵押品”（collateral）为支持、可在链上 mint（铸造）和 redeem（赎回）的稳定币。通常，用户先用某种抵押资产（例如 USDC、DAI 等）在 `mint()` 函数中铸造等值的 YUSD；之后，当用户想要赎回时，会提交一个赎回请求（RedeemRequest），等待由持有 `FUNDS_MANAGER_ROLE` 的角色调用 `approveRedeemRequest()` 来完成赎回：把用户先前抵押的资产退给他们，并销毁等量的 YUSD。<br />报告指出，在 `approveRedeemRequest()` 的流程中，协议将「全额抵押物」直接返还给用户，但同时会按照赎回金额（`yusdAmount`）抽取一笔手续费（redeem fee），把这笔手续费以 YUSD 形式发往insurance fund，并销毁剩余 YUSD。由于退款时退回的抵押物数量是按“赎回前的 YUSD 总额”来算，而手续费部分对应的 YUSD 并未在之前为其预留抵押品，就造成「未被任何抵押物支持的 YUSD」存在。这些未被抵押品覆盖的 YUSD 是可以再用来赎回抵押物的，久而久之，协议里的抵押品储备就会被一点一点提光，导致 YUSD 与美元挂钩的稳定性（peg）崩塌——也就是“去锚”（depeg） | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | Logic error                                                  | Stable Coin                                   | B      | 稳定币存在脱锚的情况，即出现了没有抵押物但是mint了coint的存在 |
| 90   | Aegis 协议的 minting 合约（AegisMinting.sol）本意是“自持无余”，即所有用户在 mint YUSD 时上链的抵押品，都会立即转给外部的托管方（custodial partners）保管；当用户赎回 YUSD 时，协议再从托管方提回对应的抵押品给用户。按照官方叙述，mint 合约本身不应长期持有用户抵押的资产，交易过程中的资金流向应当是“用户→合约→托管方（mint 时）”以及“托管方→合约→用户（redeem 时）”。<br />但是，报告指出，在现实使用中，以下两种资金状态会被“未追踪”（untracked）地滞留在 mint 合约中：<br />**待赎回（pending）但最后未执行的赎回请求对应的抵押品**。即：当用户发起赎回，协议从托管方提回抵押品到合约后，因多种原因（如用户取消赎回、订单过期、slippage 导致验资失败、黑名单限制等）赎回请求最终没有被批准，已提回的抵押品就会卡在合约里。 <br />**将其视为“协议收益（profit）”时，可能会调用 `depositIncome` 把这些卡住的fund当作新增收入并铸造 YUSD**，从而导致部分 YUSD 并没有相应抵押品支持。 | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | Logic error(记账混乱)                                        | Stable Coin                                   | S      | 本质原因是由于redeem的两个非连续的步骤，中间如果没成功。<br />同时穿插了其他`balanceOf(this)`的accounting记账，导致的记账混乱，错误地记成了收入。 |
| 91   | Aegis 协议中为了限制单个周期内的铸造（mint）和赎回（redeem）总量，引入了一个“周期限额”（MintRedeemLimit）机制。其核心思路是： **限额配置**  每个周期（`periodDuration`，例如 24 小时）都有一个最大可赎回 YUSD 总量：`redeemLimit.maxPeriodAmount`。 **实时计数器**  当有人发起赎回请求（`requestRedeem`）时，会检查当前这一周期里已提交（或“占用”）的赎回总量 `limits.currentPeriodTotalAmount`，确保它与本次请求量相加不超过 `maxPeriodAmount`。如果超过，则交易会 revert（抛出 `LimitReached` 错误）。 **周期刷新**  当距离上一次记录超过 `periodDuration` 时，合约会将 `limits.currentPeriodTotalAmount` 重置为 0，开启新一轮的周期计算。  <br />正常情况下，用户发起赎回请求时，便先“占用”一定额度；如果请求最终成功、或最终失败（被拒绝或撤销），就应该相应地“释放”这部分额度，保证限额对所有用户公平生效。<br />**然而，Issue M-2 发现：当前合约在“用户撤销赎回”或“赎回被拒绝”时，并没有把之前在 `currentPeriodTotalAmount` 中累加的额度扣回。**换言之，只要用户（或恶意鲸鱼）发起了一笔赎回，就把额度算进去了；即便后来撤销，额度依旧保持占用状态，直到周期结束才自然清零。由此，鲸鱼即可通过批量发送赎回请求，然后在它们过期后逐一撤销，令这一周期内的 `currentPeriodTotalAmount` 维持在一个极高值或逼近上限，从而让同周期内其他用户无法再发起新的赎回——形成了“赎回功能被恶意阻塞（griefing）”的局面。 | [Aegis](https://audits.sherlock.xyz/contests/799/report)     | DoS                                                          | Stable Coin                                   | B      | 这是一个关于限额的问题，即如果有人恶意用掉了限额会不会产生DoS。 |
| 92   | 合约允许用户通过`overrideReceiver()`将现有的奖励收款账户转移成另一个。并调用`_migrateRewards(msg.sender, overrideAddress)`将现在记录的奖励转给新地址。<br />于此同时`removeOverrideAddress()`，又可以调用`_migrateRewards(overrideAddresses[msg.sender], msg.sender)`，将之前的override换成msg.sender账户。<br />这样一来一回，可以将其他人的高奖励账户的reward换成自己的。 | [mev-commit](https://cantina.xyz/code/e92be0b9-b4f2-4bf2-9544-ae285fcfc02d/findings/15) | Logic error                                                  | MEV                                           | B      | 狸猫换太子                                                   |
| 93   | 当向外部转账，有人可以使用没写receive/fallback的合约来导致潜在的DoS | [GuardianAuditor](https://lab.guardianaudits.com/encyclopedia-of-solidity-attack-vectors/contract-cannot-accept-ether-dos) | DoS                                                          |                                               |        | Unpayable DoS                                                |
| 94   | 管理这个forward合约的router没有对应的方法对onlyAdmin合约进行调用 | [OZ-across](https://blog.openzeppelin.com/across-audit#no-way-to-invoke-some-privileged-functions-of-forwarders) |                                                              |                                               |        |                                                              |
| 95   |                                                              |                                                              |                                                              |                                               |        |                                                              |
| 96   | **H1:**Type casting issue<br />**H2:**External call without protection<br />**H3:**缺乏重入保护<br />**H4:**修改订单缺乏检查订单是否已取消<br />**H5:**Approve uint256.Max 过量的approve导致损失<br />**H6:**Approve(target, order.amountIn)假设用户会花完额度，但是如果没花完的额度就会出问题，和H5一样是没清空额度导致的问题<br />**H7:**订单生成号缺乏nonce导致碰撞，而导致double-spending<br />**H8:**pullToken的对象是一个可输入的对象，而不是`msg.sender`导致attacker可输入它人账户，使得它人approve后，抢跑进行如griefing等攻击。 | [Oku's Trade](https://audits.sherlock.xyz/contests/641/report) |                                                              |                                               |        |                                                              |
| 97   | **M1:** 当使用USDT的0x地址作为recipient时，USDT无法转账到该地址，导致管理员无法cancel此类Order，导致Array徒增出现DoS。<br />**M2：** Typos issue，大于小于写反了<br />**M3:**订单中的方向无法被用户决定，有可能南辕北辙<br />**M4:** 旧版本的OZ，`safeApprove`不允许此token的allowance在之前没被清空，导致DoS<br />**M5:** Missing checks for feeBip settlement<br />**M6:**没有whitelist导致可创建任意不允许OracleLess合约转账的token使管理员无法取消订单，进行array griefing<br />**M7**:类似M1的griefing，但是这次是用blackList转账<br />**M8**：还是ArrayGriefing，原因是admin无法slash恶意订单，而只允许refund<br />**M9**：两个stopLimit订单会沿用`_createOrder()`，此时美元价格掉到MiniAmount下，但是之前创建成功的订单会被错误的`checkMiniAmount`检查位置给Block<br />**M10**: ArrayGriefing，无法取消订单<br />**M11:** 0元的Amount的订单可创建，制造ArrayGriefing。 | [Oku's Trade](https://audits.sherlock.xyz/contests/641/report) |                                                              |                                               |        |                                                              |
| 98   | ETH0和liquid staking token (e.g. wstETH, rETH) 铆钉，这些token对ETH都是一般大于1，但是如果extreme slash event发生，可能会出现小于1的情况，而Lido oracle更新时间是日更新，任意出现滞后信息。<br />导致有人可从中套利，如原来oracle报价 1 wstETH = 1.2 ETH但是突然出事 1 wstETH = 0.5 ETH时，信息滞后，ETH0按原来的1 wstETH=1.2ETH0，换出1.2ETH0，更新后1.2ETH0换回wstETH以获利。 | [UsualETH0](https://audits.sherlock.xyz/contests/988/report) |                                                              | Stable Coin                                   |        |                                                              |
| 99   | 对于运算对象(operand),比如乘法中，uint8 x =128，uint256 y = x * 2会revert，而uint256 y = x *1000不会。<br />这是因为运算中，会选两个数中最大的空间来进行运算，第一个乘法会2满足uint8的空间，于是中间变量大小uint8，一旦进行运算就会revert。而1000 | [Solodit](https://solodit.cyfrin.io/issues/m-05-expiration-calculation-overflows-if-call-option-duration-195-days-code4rena-cally-cally-contest-git) |                                                              | Derivatives                                   |        |                                                              |
| 100  | PPS manipulation-<br />inflate shares，导致overflow从而DoS   | [Solodit](https://solodit.cyfrin.io/issues/h-9-reserve-share-overflows-due-to-too-strict-reward-calculation-mechanism-sherlock-burve-git) |                                                              |                                               |        |                                                              |
| 101  | Type casting issue, from int to uint                         | [](https://solodit.cyfrin.io/issues/integer-underflow-in-_gettargetoutput-due-to-improper-type-casting-openzeppelin-none-openzeppelin-uniswap-hooks-v110-rc-1-audit-markdown) |                                                              |                                               |        |                                                              |
| 102  | **H1**:没加modifier，但是我找到的是for loop OOG导致的dos，报告中展示的是一个duplicate storage导致奖励计算的错误<br />**H2**:参数输入的错误，关键的地址并非`msg.sender`而是可输入地址<br />**H3**:modifer issue，缺少access control<br />**H4**:modifer issue<br />**H5**:初始的validator score就是最大score，出现了逻辑错误<br />**H6**:edge case 输入0地址 | [virtuals-protocol]([Virtuals Protocol](https://code4rena.com/reports/2025-04-virtuals-protocol#high-risk-findings-6)) | H2是一个经典的input typo issue<br />H6作为0x address eddge case值得归纳 |                                               |        |                                                              |
| 103  | **M1:** 两步走的建池动作，但是customer token的建池引入了外部toke, uniswap v2建池，会导致提前建池的griefing<br />**M2:** Missing slippage  AMM<br />**M3:**虚假的内部计算slippage protection<br />**M4:**flashloan launchpad attack<br />**M5:**大师级别的先除后乘bug<br />**M6:**动态的slippage protection 类似M3<br />**M7:**uniswap中的函数没输入slippage<br />**M8:**DAO治理中无门槛的propose和castVote<br />**M9:**FERC20token其中两个关键函数onlyOwner假设owner是EOA账户，但是实际上FERC可以通过bonding合约产生，而bonding缺乏对应的<br /> |                                                              | **M1**是AMM建池抢跑griefing的案例<br />                      |                                               |        |                                                              |
|      | **M10:**改写的FERC20的`burnFrom`没有完整的totalSupply减少的逻辑<br />**M11:**ELO与白皮书假设不同（较复杂，结合实际业务）<br />**M12:**uniswap中的函数没输入slippage同M<br />**M13:**<br />**M14:** 继承合约中没有check外部人员是否也能delegate，非常深的一个继承以至于只有一个人找到<br />**M15:**edge cases<br />**M16:** typo issue in a complicated lib<br />**M17:**<br /> |                                                              |                                                              |                                               |        |                                                              |
|      | **M17:**<br />**M17:**<br />**M17:**<br />**M17:**<br />**M26:**先除后乘<br /> |                                                              |                                                              |                                               |        |                                                              |
|      | **C1:**Missing checks导致骗approve的情况<br />**H1:**冒充调用<br />**H2:**一个多步调用的系统，在订单被admin取消后并没有返回资金<br />**H3:**垫付gas，但是用户可以在执行完后withdraw余额<br />**M1:**Duplicate token允许被加入，导致的问题<br />**M2:**edge case导致手续费扣完所有的余额，导致solver无法收到资金<br />**M3:**Solver 下线的情况下，wallet无法取走资金<br />**M4:**先收了用户的gas，之后又在后面计算加了一个gas penalty，但是这个penalty在之后算的，并没有加在用户的头上，导致最终多付了这个penalty<br />**M5:**Missing checks 导致读取了stale数据<br />**M6:**逻辑问题，使用了两个minimum数进行对比来slippage protection，但是实际上我们要一个真实expectAmount和minimumAmount来进行比较<br /> | [Etherspot-GasTankPaymasterModule-Extended](https://github.com/shieldify-security/audits-portfolio-md/blob/main/Etherspot-GasTankPaymasterModule-Extended-Security-Review.md#7-findings) |                                                              |                                               |        |                                                              |
|      | **H1:**逻辑错误，提前更新了burn参数导致其奖励还不如其一般的stake模式的奖励<br />**M1:**Admin允许修改rewardRate参数，导致能直接改变用户的奖励数量造成前后奖励不一致。 | [HoneypotFinance-NFTStaking-Security-Review.md ](https://github.com/shieldify-security/audits-portfolio-md/blob/main/HoneypotFinance-NFTStaking-Security-Review.md#7-findings) | 奖励机制设计考虑的的不健全                                   |                                               |        |                                                              |
|      | **H1:**当协议启用协议费用时，系统会在`_calculateMarketState`函数中计算累计协议费用（accruedProtocolFee）。这个费用应该从baseTokenSupply中扣除并添加到protocolFeeGrowth中。然而，在费用扣除后，多个关键操作仍然使用扣除前的baseTokenSupply值，导致状态计算错误。<br /> | [Covenant-pashov/audits](https://github.com/pashov/audits/blob/master/team/md/Covenant-security-review_2025-08-18.md#findings) |                                                              |                                               |        |                                                              |
|      | M1: 作者以为创建新的变量能override变量<br />M2: edge case导致DoS<br />M3:经典时间锁grief<br />M4:Redeem有cap检查，但是swap没有导致可以bypass这个全局限制<br />**M5:** mint函数有`_checkUnderCollateralized`的杠杆限制，attacker可以在早期操作debt到max debt后，资产下跌将使得`_checkUnderCollateralized`阻止其他人调用mint | [Covenant-pashov/audits](https://github.com/pashov/audits/blob/master/team/md/Covenant-security-review_2025-08-18.md#findings) |                                                              |                                               |        |                                                              |
|      |                                                              |                                                              |                                                              |                                               |        |                                                              |
|      |                                                              |                                                              |                                                              |                                               |        |                                                              |

















## Check list

deposit/withdraw: 

前置check是否正确处理，

比如检查了最大存/取额度（可能是vault中的token有限，不能存取超过最大额度）

是否有period limit（不允许的period用于无法存取）

是否正确处理了角色（attack是否能存/取别人的钱？）

0值是否会导致问题？比如存0但是取不为0

是否有存款，withdraw的所产生的array push导致dos ?（快速发送大量存取信息导致其他用户无法正常存取）

是否有flash-deposit获利的情况





