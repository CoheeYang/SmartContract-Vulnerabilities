### 第一部分：以太坊中动态变量的存储方式

在以太坊中，所有数据都存储在**存储**中，这是一个巨大的键值对映射（key-value store），其中键和值都是32字节。动态变量的存储遵循一套精密的规则：

#### 1. **动态数组**

- **长度存储**：在预定义的存储槽位置 `p` 存储数组的长度。
- **元素存储**：数组的元素从 `keccak256(p)` 开始的连续存储位置存储。
- **示例**：`uint256[] public arr;` 存储在槽0。`arr.length` 存储在槽0，`arr[0]` 存储在 `keccak256(0)`，`arr[1]` 存储在 `keccak256(0) + 1`，依此类推。

#### 2. **映射**

- **无集中存储**：映射本身不存储任何元素，只作为一个"起始点"。
- **分散存储**：每个键 `k` 对应的值存储在 `keccak256(h(k) . p)`，其中：
  - `p` 是映射的存储槽位置，不存储任何数据，其数值为0.
  - `h(k)` 是对键 `k` 进行适当填充到32字节的函数
  - `.` 表示连接符
- **示例**：`mapping(address => uint256) public balances;` 在槽1。`balances[0x123...]` 的值存储在 `keccak256( pad(0x123...) . 1 )`。

#### 3. **字节数组和字符串**

字节和字符串的编码方式相同。一般来说，其编码方式与 bytes1 [] 类似，即存在一个用于数组本身的槽位，以及一个通过该槽位位置的 keccak256 哈希计算得到的数据区域。不过，对于短值（短于 32 字节），数组元素会和长度一起存储在同一个槽位中。

具体而言：如果数据长度最多为 31 字节，元素会存储在高位字节（左对齐），而最低位字节存储的值为长度 ×2。对于存储的数据长度为 32 字节或更长的字节数组，主槽位 p 存储长度 ×2 + 1

- **短（length ≤ 31）**：值直接存放在槽 `p` 本身。具体地，槽内最低有效字节（least-significant byte，LSB）保存 `length * 2`（即 `length << 1`）；其余高位字节存放数据（data 被移位放在槽的高位部分）。换句话说，槽的布局是 `(data << 8) | (length << 1)`.而之所以要左移一位，是为了最低位置放一个0/1的flag，来告诉程序这到底是短的还是长的存储方法，如果是短的就是0，会直接读取这里的数据

  此时数据应该长这样：

  ```solidity
  storage[p] = (data << 8) | (length << 1) | flag=0
  ```

  

- **长（length ≥ 32）**：槽 `p` 不直接放数据，而在槽中存放一个奇偶标志形式的长度编码：`(length << 1) | 1`（即 `length * 2 + 1`，最低位为 1 标识为“外部存储”）。数据本体从 `keccak256(p)` 开始按 32 字节块顺序连续存储（`keccak256(p) + 0`、`+1` …）。

  此时数据应该是：

  ```solidity
  storage[p] = (length << 1) | 1
  storage[keccak256(p)] = data1
  storage[keccak256(p)+1] = data2 
  ....
  ```

  

#### 4. **结构体中的动态变量**

在结构体中，动态变量按照声明顺序分配存储槽，但实际数据可能分散在不同位置：

```solidity
struct User {
    uint256 id;
    mapping(address => uint256) balances; // 仅占一个槽位，但数据分散存储
    string name; // 可能占用多个实际存储位置
}
```

