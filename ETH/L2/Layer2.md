



# Layer2

## Intro

**Layer2的作用：**

以太坊扩容，增加TPS，并减少交易成本



**Layer2与Layer1的关系：**

简单来说的话：

Layer1(共识层)->Layer2(结算层)->Layer3(应用层)

但是实际上以太坊已经到了模块化的进程，具体模块拆分的要比上述更加细致。

“模块化”（modularity）指的是将区块链的核心功能——共识（Consensus）、数据可用性（Data Availability）、执行（Execution）、结算（Settlement）等——拆分成相互独立、可组合的组件（模块），并允许各个模块由不同的系统或网络来提供和优化。相比于“单片式”（monolithic）架构，模块化设计具有更高的灵活性、可扩展性和创新空间。

具体来说，比如有以下模块化的方式：

1. **共识层：**ETH (PoS)
2. **DA层：**Celestia、Kroma Data Availability，Anytrust，EigenDA，[EIP4844](https://www.ethereum.cn/Eth2/4844-design)
3. **L2层**：
   - RollUp (Tx rollup & Proof Rollup)
   - Sequencer
   - Verifier
   - Prover
4. **L3层**：所有的应用软件

------

**Layer2的职责：**<br/>

Layer2并不使用任何共识算法保证安全性，其所有的安全性来自于底层的L1的共识算法，L2仅仅作为交易结算层来执行链上应用的交易。

而至于其如何完成上述的功能，大致可以分为两部分：

1. 创建一个是负责处理交易的Layer 2网络；
2. 部署一个在底层区块链上的合约，负责解决任何分歧，并将Layer 2达成的共识传输到底层区块链进行验证。

这些Layer 2网络有一个共同点，那就是在结算时都会向底层区块链提交某种可验证的加密证明，以证明状态变更的真实性；简单来说，就是在L1上**保存能够验证交易过程的凭证**从而利用L1的安全性保证L2上交易的安全性。



之前说的`Sequencer`&`Rollup`等各个模块则在这里起着至关重要的作用：

- **Sequencer:**交易排序器， 是一个链下节点（客户端），负责接收用户交易、排序并生成 L2 区块或交易批次

Rollup

提交交易数据到DA

提交交易证明到L1



- **DA**：

Verifier:交易证明器，部署在L1中，其核心职责是 **对 L2 提交的状态更新或证明进行验证**，保证只有合法的、经过证明的状态转移才能被 L1 接受并最终结算。

RPC:转发用户交易和提供外部服务

Prover：链下证明器



## Fraud-Proof & ZK-Proof

### Fraud-Proof

在 Layer 2 的 Optimistic Rollup 架构中，**欺诈证明（fraud‑proof）** 是确保提交到主链（L1）的状态更新真实有效的关键机制。其核心思路是：

1. **乐观假设**
    任何提交到 L1 的状态根（state root）和交易序列默认视为正确，不需要立即在 L1 上重新执行验证，从而大幅提升吞吐量和降低费用。
2. **争议期窗口（Dispute Time Delay, DTD）**
    为了防止恶意提交，系统为每一批状态更新设置一个“争议期”窗口（例如几小时到几天不等）。在此窗口内，任何人都可以对某次状态更新发起挑战。
3. **保证金与经济激励**
    提交者（sequencer）在发布状态时需要缴纳一定的保证金；一旦被证明存在欺诈，其保证金将部分或全部没收，并奖励给挑战者。

------

## 欺诈证明的两种实现方式

| 实现方式             | 核心思路                                                     | 代表项目              |
| -------------------- | ------------------------------------------------------------ | --------------------- |
| **非交互式欺诈证明** | 在 L1 上完整重演提交的所有交易，验证得到的状态根是否与提交值一致。 | Optimism, Metis, BoBA |
| **交互式欺诈证明**   | 提交者与挑战者之间进行多轮“二分”或“K 分”对话，每次聚焦一个小区间，最终定位到出错的指令，并只在 L1 重演该指令。 | Arbitrum              |

### 1. 非交互式欺诈证明（Optimism 示例）

- **过程**：
  1. Sequencer 将前一状态根、交易列表和新的状态根一起提交到 L1 合约。
  2. 挑战者若质疑该更新，提供完整的前一状态树与交易序列，由 L1 重新执行所有交易。
  3. 若执行后的根与提交值不符，则判定为欺诈，执行回滚与罚没保证金。
- **环境一致性问题**：
   由于 L2 与 L1 的执行环境存在差异（如 `block.timestamp`），Optimism 引入了 **OVM（Optimistic Virtual Machine）**，对链上环境变量进行封装（如 `ovm_getTimestamp`/`ovm_setTimestamp`），确保在 L1 重演时能使用与 L2 相同的上下文数据。

### 2. 交互式欺诈证明（Arbitrum 示例）

- **“二分查错”思路**：
  1. Sequencer 声称从状态 A 执行 N 条指令后到达状态 B。
  2. 挑战者要求提供第 N/2 条指令执行后的中间状态 X。
  3. 验证前 N/2 指令是否正确：若正确，则问题在后半段；否则问题在前半段。
  4. 重复该流程，最终精确定位到具体“出错指令”，只需在 L1 重演这一条指令。
- **AVM 支持**：
   Arbitrum 设计了 **AVM（Arbitrum Virtual Machine）**，在每条指令中除了存储当前操作码，还存储下一条指令位置及其哈希，以便在争议时能逐步验证指令执行的正确性。

------

## 两种方案的对比

| 特性               | 交互式欺诈证明                         | 非交互式欺诈证明                    |
| ------------------ | -------------------------------------- | ----------------------------------- |
| **EVM 兼容性**     | 完全保留 EVM 原生指令集，可原生执行    | 需通过 OVM 层虚拟化，部分合约需改写 |
| **挑战成本**       | 只需在 L1 重演有争议的单条指令，Gas 低 | 重演所有交易，Gas 成本高            |
| **合约复杂度支持** | 支持任意复杂度，与 L1 相同             | 受 L1 Gas 限制，复杂合约受限        |

由此可见，虽然交互式欺诈证明实现复杂度更高，但在兼容性、成本和可扩展性上都更具优势。Optimism 等非交互式方案的代表者也已计划向交互式欺诈证明迁移，未来该机制有望成为主流。同时，这类欺诈证明的最大痛点——长提款（withdrawal）延迟，将随着 zk‑rollup 等无需争议期的技术逐步得到解决。

https://github.com/zgos/layer2-study/blob/main/src/fraud-proof.md







