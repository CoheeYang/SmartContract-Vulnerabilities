Defi项目中常常会根据业务设计不同的架构模式。

### 可升级合约架构

从基础的可升级架构都有常见的

1. **Proxy+Implementation**
   - 一般是三种模式：Transparent Proxy、UUPS、Beacon Proxy
   - 然后加上ERC7201的槽位管理方式规避slot collision

总结区别的话就是：

1. Transparent Proxy的合约升级逻辑在proxy中，即有一个`UpgradeToAndCall`，需要proxyAdmin合约调用，防止撞车。
2. UUPS合约升级逻辑在impl中，每个impl需要继承一个抽象，`UpgradeToAndCall`作为owner函数，之后delegate call来改掉impl
3. beacon作为存储多个proxy对应impl额外合约，方便了多个可升级合约的管理。



透明代理合约大概长这样：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContractTransparentV2 is Initializable {
    uint256 public value;
    string public name;
    address public owner;
    uint256 public timestamp; // 新增状态变量
    
    event ValueChanged(uint256 newValue);
    event NameChanged(string newName);
    event TimestampUpdated(uint256 newTimestamp);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function initialize(uint256 _value, string memory _name) public initializer {
        value = _value;
        name = _name;
        owner = msg.sender;
        timestamp = block.timestamp; // 新增功能
    }

    function setValue(uint256 _value) external {
        value = _value;
        emit ValueChanged(_value);
    }

    function setName(string memory _name) external onlyOwner {
        name = _name;
        emit NameChanged(_name);
    }

    // 新增功能
    function updateTimestamp() external {
        timestamp = block.timestamp;
        emit TimestampUpdated(timestamp);
    }

    function getOwner() external view returns (address) {
        return owner;
    }
}
```

透明代理除了要部署proxy+imp外，还需要一个proxyAdmin作为管理升级的合约（如果proxyAdmin设为EOA账户，那么fallback的时候EOA账户会被if条件限制，只能做升级动作），来调用合约的UpgradeToAndCall。

```solidity
// 在 TransparentUpgradeableProxy 中的逻辑
// 正确的透明代理设计
contract ProperTransparentProxy {
    address public proxyAdmin;  // 专门的 ProxyAdmin 合约
    address public implementation;
    
    constructor(address _implementation, address _proxyAdmin) {
        implementation = _implementation;
        proxyAdmin = _proxyAdmin;
    }
    
    fallback() external payable {
        if (msg.sender == proxyAdmin) {
            // 只有 ProxyAdmin 可以调用升级函数
            _dispatchUpgrade();
        } else {
            // 所有其他地址（包括管理员EOA）都转发到实现合约
            (bool success, ) = implementation.delegatecall(msg.data);
            require(success);
        }
    }
    
    function _dispatchUpgrade() internal {
        // 处理升级逻辑
    }
}

// ProxyAdmin 合约
contract ProxyAdmin {
    address public owner;
    
    constructor(address _owner) {
        owner = _owner;
    }
    
    function upgradeAndCall(
        address proxy, 
        address newImplementation, 
        bytes memory data
    ) external onlyOwner {
        // 通过代理合约执行升级
        TransparentUpgradeableProxy(payable(proxy)).upgradeToAndCall(
            newImplementation, 
            data
        );
    }
}
```



UUPS则更加轻量化，因为其升级逻辑是放在实现合约中的，而不是代理合约中。

合约继承UUPSUpgradeable抽象后

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract MyContract is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    uint256 public value;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(uint256 _value) public initializer {
        __UUPSUpgradeable_init();
        __Ownable_init(msg.sender);
        value = _value;
    }

    function setValue(uint256 _value) external {
        value = _value;
    }

    // 重写 _authorizeUpgrade 函数以添加访问控制
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {
        // 只有所有者可以授权升级，使得owner和proxyAdmin都可以是一个人。
    }
}

```

这是通过函数`upgradeToAndCall`实现的，但是这个函数使用`onlyProxy`来验证

```solidity
// UUPSUpgradeable 提供的核心升级函数
function upgradeToAndCall(address newImplementation, bytes memory data) 
    public payable virtual onlyProxy {
    _authorizeUpgrade(newImplementation);
    _upgradeToAndCallUUPS(newImplementation, data);
}
```

```solidity
// 关键的安全检查
modifier onlyProxy() {
    _checkProxy();
    _;
}

function _checkProxy() internal view virtual {
    if (
        address(this) == __self || // 必须通过 delegatecall
        ERC1967Utils.getImplementation() != __self // 必须是活跃代理
    ) {
        revert UUPSUnauthorizedCallContext();
    }
}
```



beacon proxy更好理解，即一个beacon只作为写入各个proxy的对应的Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/proxy/Proxy.sol";
import "@openzeppelin/contracts/proxy/beacon/IBeacon.sol";

//proxy合约
contract BeaconProxy is Proxy {
    // 信标合约地址（不可变，部署时设置）
    address private immutable _beacon;

    constructor(address beacon, bytes memory data) {
        _beacon = beacon;
        // 可选：初始化调用
        if (data.length > 0) {
            Address.functionDelegateCall(_implementation(), data);
        }
    }
	//从beacon里找逻辑合约。
    function _implementation() internal view virtual override returns (address) {
        return IBeacon(_beacon).implementation();
    }
    
    function getBeacon() public view returns (address) {
        return _beacon;
    }
}
```





```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/proxy/beacon/IBeacon.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
//以一个为例，多个合约拿mapping，proxy地址=>implementation对应
contract UpgradeableBeacon is IBeacon, Ownable {
    address private _implementation;
    
    event Upgraded(address indexed implementation);

    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {
        _setImplementation(implementation_);
    }

    function implementation() public view virtual override returns (address) {
        return _implementation;
    }

    function upgradeTo(address newImplementation) public virtual onlyOwner {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    function _setImplementation(address newImplementation) private {
        require(newImplementation.code.length > 0, "Beacon: implementation is not a contract");
        _implementation = newImplementation;
    }
}
```







2. **ERC-2535: Diamonds, Multi-Facet Proxy**

Proxy+Implementation的可升级合约都是弄一个implementation就要有一个proxy，这样我们就有很多个合约对，导致管理混乱。同时也会有很多个合约入口，难以管理；比如我们作为admin设置参数，得找到对应的合约proxy，然后才能设置参数。

所以就有人想到Diamonds模式的升级合约，将不同逻辑合约作为Facet，而只需要保留一个或者少量的Dimond作为proxy，并利用函数签名的mapping来进行delegatecall，当升级时就添加或者修改`facets`的mapping存储即可。

![Mapping facets and storage](https://eips.ethereum.org/assets/eip-2535/DiamondDiagram.png)

比如一个AdminFacet作为管理Admin所有参数的逻辑，Deposit/WithdrawFacet来管理对应的业务逻辑，这些逻辑合约都不需要写具体的storage，只需要在lib中调用storage就可以。这种模式就类似于Solana存储和合约分离的模式，能更加高效地进行升级和管理。

比如下面的AdminFacet中的函数，通过两个lib进行了owner的检查和参数的设置：

```solidity
    function setFeeCurve(address pool, SmoothRateCurveConfig calldata feeCurve) external {
        AdminLib.validateOwner();
        Store.fees().feeCurves[pool] = feeCurve;
        emit FeeCurveSet(pool, feeCurve);
    }
```

```solidity
library AdminLib {
    bytes32 public constant ADMIN_STORAGE_POSITION = keccak256("v4.admin.diamond.storage");
    
    function adminStore() internal pure returns (AdminRegistry storage adReg) {
        bytes32 position = ADMIN_STORAGE_POSITION;
        assembly {
            adReg.slot := position
        }
    }
    function validateOwner() internal view {
        if (msg.sender != adminStore().owner) {
            revert NotOwner();
        }
    }
 .....
    }
```











hub satellites

Handler-
